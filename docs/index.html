<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<h1 id="sofs2017"><strong>sofs2017</strong></h1>
<hr />
<blockquote>
<p><em>The sofs17 is a simple and limited file system, based on the ext2 file system, which was designed for purely educational purposes and is intended to be developed in the practical classes of the Operating Systems course in academic year of 2017/2018. The physical support is a regular file from any other file system.</em></p>
</blockquote>
<hr />
<ul>
<li>Sistema simples e limitado</li>
<li>Baseado no ext2</li>
<li>Suporte físico: um ficheiro regular de outro sistema operativo
<ul>
<li>Este ficheiro será formatado para imitar uma unidade física formatada no formato sofs17</li>
</ul></li>
</ul>
<h1 id="organização-das-aulas-durante-o-sofs17">Organização das aulas durante o sofs17</h1>
<p>2 horas:<br />
- 1h30 : interagir relativamente ao trabalho pendente<br />
- 0h30 : falar da próxima camada de software<br />
</p>
<h1 id="introduction">1. Introduction</h1>
<ul>
<li>Durante a execução de um programa, ele manipula informação (produz, acede e/ou modifica).</li>
<li>Esta informação tem de ser guardada exteriormente (<strong>mass storage</strong>)
<ul>
<li>discos magnéticos</li>
<li>discos ópticos</li>
<li>SSD</li>
<li>…</li>
</ul></li>
<li><strong>mass storage</strong> (armazenamento de massa): dispositivos organizados em arrays de blocos
<ul>
<li>256 bytes até 8 Kbytes por bloco</li>
<li>os blocos são numerados sequencialmente (LBA model)</li>
<li>o acesso para R/W é efetuado através de um ID (identification number)<br />
</li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th align="center">Block 0 |</th>
<th align="center">Block 1 |</th>
<th align="center">Block 2 |</th>
<th align="center">Block 3 |</th>
<th align="center">…</th>
<th align="center">Block NTBK-1</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>Cada bloco tem BKZS bytes de informação - O acesso ao disco é feito bloco a bloco: - <strong>Não é possível modificar um único byte</strong></p>
<hr />
<blockquote>
<p><em>Direct access to the contents of the device <strong>should not be allowed to the application programmer.</strong> </em></p>
</blockquote>
<hr />
<p>Porque:</p>
<ul>
<li>Um sistema de ficheiros é complexo</li>
<li>A sua estrutura interna precisa de <em>enforce quality criteria</em> para garantir:
<ul>
<li>eficiência</li>
<li>integridade</li>
<li>partilha de acessos</li>
</ul></li>
<li>O utilizador não sabe o conteúdo de cada bloco de dados nem em que blocos a informação do ficheiro x está.</li>
</ul>
<p>Daí a necessidade/exigência da existência de um <em>uniform interaction model</em> (Nível de abstração).<br />
</p>
<p><strong>ficheiro</strong>:</p>
<ul>
<li>unidade lógica de armazenamento de massa</li>
<li><em>abstract data type</em>, sobre o ponto de vista do programador
<ul>
<li>composto por um conjunto de atributos e operações</li>
</ul></li>
<li>tipos:
<ul>
<li>NTFS</li>
<li>ext3</li>
<li>FAT*</li>
<li>UDF</li>
<li>APFS</li>
<li>…</li>
</ul></li>
</ul>
<hr />
<blockquote>
<p><em>Is the operating system’s responsability to provide a set of from the file system point of view: system calls that implement such abstract data type. These system calls should be a simple and safe interface with the mass storage device. The component of the operating system dedicated size — the size in bytes of the file’s data to this task is the file system</em></p>
</blockquote>
<hr />
<p>Ou seja, operações de leitura e escrita <strong>são sempre efetuadas no contexto de ficheiros</strong>, através de syscall disponibilizadas pelo OS.</p>
<p>A interface de comunicação com o OS é a mesma, mas diferentes sistemas de ficheiros obrigam a diferentes técnicas e manipulação do filesystem, que são transparentes para o programador.</p>
<h2 id="file-as-an-abstract-data-type">1.1 File as an abstract data type</h2>
<p>Os atributos de um ficheiros dependem da implementação do sistema de ficheiros.</p>
<p>Os mais comuns:</p>
<ul>
<li><strong>name</strong>:</li>
<li><strong>internal identifier</strong>: ID númerico (e interno - o user desconhece) que é usado pelo OS para aceder ao ficheiro</li>
<li><strong>size</strong>: tamanho do ficheiro em bytes</li>
<li><strong>ownership</strong>: Identificação de quêm o ficheiro pertence (usado para controlo de acessos)</li>
<li><strong>permissions</strong>: Atributos que em conjunto com a ownership (des)autorizam o acesso ao ficheiro
<ul>
<li>Possíveis permissões:
<ul>
<li>r: read</li>
<li>w: write</li>
<li>x: execute</li>
<li>d: directory</li>
</ul></li>
<li>Nos diretórios, execução <code>x</code> significa que eu tenho permissões para atravessar o diretório (posso não ter permissões nem para ler nem para escrever, mas posso seguir no diretório para chegar a outro path)</li>
</ul></li>
<li><strong>acess monitoring</strong>: data do último acesso e última modificação</li>
<li><strong>localization of the data</strong>: identificação dos clusters onde os dados do ficheiros estão guardados</li>
<li><strong>type</strong>: tipo dos ficheiros:
<ol style="list-style-type: decimal">
<li>ordinary or regular: qualquer ficheiro &quot;normal&quot; para o utilizador [ID= - ]
<ul>
<li>.txt</li>
<li>.doc</li>
<li>.png</li>
<li>.avi</li>
<li>.mp3</li>
<li>.pdf</li>
<li>.c</li>
<li>.exe</li>
<li>…</li>
</ul></li>
<li>directory: um tipo de <strong>ficheiro</strong> interno, com um formato pre-definido, usado para localizar outros ficheiros ou diretórios, permitindo visualizar o sistemas de ficheiros como uma árvore de diretórios e fichieros [ID= d]</li>
<li>shortcut (symbolic link): ficheiro interno, com um formato predefinido, que contém uma referência para outro ficheiro/diretório [ID= s]
<ul>
<li>ref pode ser absoluta ou relativa</li>
</ul></li>
<li>character device(<strong>special file</strong>): <em>represents a device handles in bytes</em> [ID= c]</li>
<li>block device(<strong>special file</strong>): <em>rep esents a device handles in block</em> [ID= b]</li>
<li>socket(<strong>special file</strong>): <em>represents a file used for inter-process communication</em> [ID= s]</li>
<li>named pipe: <em><strong>another special file</strong> used for inter-process communication</em> [ID = p]</li>
</ol></li>
</ul>
<table>
<thead>
<tr class="header">
<th align="center">ID (<code>ls -ll</code>)</th>
<th align="center">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">-</td>
<td align="center">ordinary/regular file</td>
</tr>
<tr class="even">
<td align="center">d</td>
<td align="center">directory</td>
</tr>
<tr class="odd">
<td align="center">s</td>
<td align="center">symbolic link</td>
</tr>
<tr class="even">
<td align="center">c</td>
<td align="center">character device</td>
</tr>
<tr class="odd">
<td align="center">b</td>
<td align="center">block device</td>
</tr>
<tr class="even">
<td align="center">s</td>
<td align="center">socket</td>
</tr>
<tr class="odd">
<td align="center">p</td>
<td align="center">named pipe</td>
</tr>
</tbody>
</table>
<p>No sofs17 só serão considerados os três primeiros tipos de ficheiros.</p>
<h3 id="operações-em-ficheiros">Operações em ficheiros</h3>
<ul>
<li>Dependem do OS</li>
<li>Todas as operações estão disponíveis <strong>apenas</strong> através de syscalls (funções que funcionam como <em>entry-points</em> para o OS</li>
<li><p>Syscalls em Linux para os tipos de ficheiros a usar no sofs17:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*[</span><span class="al">TODO</span><span class="co">] Inserir descrição das operações para o teste*/</span></code></pre></div>
<ul>
<li>Comun aos três:
<ul>
<li>open</li>
<li>close</li>
<li>chmod</li>
<li>chown</li>
<li>utime</li>
<li>stat</li>
<li>rename</li>
</ul></li>
<li>Comun para <strong>ficheiros regulares</strong> e <strong>shortcuts</strong>:
<ul>
<li>link</li>
<li>unlink</li>
</ul></li>
<li>Só para <strong>ficheiros regulares</strong>:
<ul>
<li>mknod</li>
<li>read</li>
<li>write</li>
<li>truncate</li>
<li>lseek</li>
</ul></li>
<li>Só para <strong>diretórios</strong>
<ul>
<li>mkdir</li>
<li>rmdir</li>
<li>getdents</li>
</ul></li>
<li>Só para <strong>shortcuts</strong>
<ul>
<li>symlink</li>
<li>readlink</li>
</ul></li>
</ul></li>
</ul>
<p>A descrição destas syscalls pode ser obtida executando num terminal o comando:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">man</span> 2 <span class="op">&lt;</span>syscall<span class="op">&gt;</span></code></pre></div>
<h2 id="fuse">1.2 FUSE</h2>
<p>Inserir um novo filesystem num OS requer: 1. Integração do software que implementa o novo filesystem no kernel 2. Instanciação de um ou mais dispositivos que usam o formato do novo filesystem</p>
<blockquote>
<p><em>In monolitic kernels, the integration task involves the recompilation of the kernel, including the sofware that implements the new file system. In modular kernels, the new software should be compiled and linked separalely and attached to the kernel at run time.</em></p>
</blockquote>
<p>Tarefa morosa e difícil, que requer <em>deep knowledge of the hosting system</em> - <strong>OUT OF THE SCOPE OF SO</strong></p>
<blockquote>
<p>FUSE (File system in User SpacE) is a canny solution that <strong>allows for the implementation of file systems in user space</strong> (memory where normal user programs run). Thus, <strong>any effect of flaws of the suporting software are restricted to the user space, keeping the kernel imune to them.</strong></p>
</blockquote>
<p>O novo filesystem é executado em cima do FUSE com permissões de user e não de root. Assim, certas operações que poderiam danificar fisicamente os dispositivos estão interditas e erros no código não geram kernel-panics.</p>
<p>Isola-se a execução deste novo filesystem do kernel.</p>
<h3 id="infrastrutura">Infrastrutura</h3>
<ul>
<li><strong>Interface com o filesystem nativo</strong>: funciona como mediador entre as syscalls do sistema nativo e as implementadas em user sapce</li>
<li><strong>Implementation library</strong>:
<ul>
<li>Estruturas de dados</li>
<li>Protótipos de funções (que devem ser desenvolvidas pelo user para criar o filesystem específico)</li>
<li>Métodos para instanciar e integrar o novo filesystem com o kernel</li>
</ul></li>
</ul>
<div class="figure">
<img src="../Pictures/fuse.jpeg" alt="FUSE diagram with sofs17" />
<p class="caption">FUSE diagram with sofs17</p>
</div>
<h1 id="sofs17-architecture">2 SOFS17 Architecture</h1>
<ul>
<li>Um disco é um conjunto de blocos numerados
<ul>
<li>No sofs17 cada bloco tem 512 bytes</li>
</ul></li>
<li>Os elementos principais na definição da arquitectura do sofs2017 são:
<ul>
<li><strong>superblock</strong>: estrutura de dados guardada no bloco 0. Contém atributos globais para
<ul>
<li>o disco como um todo</li>
<li>outras estruturas de dados</li>
</ul></li>
<li><strong>inode</strong>: estrutura de dados que contém <strong>todos os atributos de um ficheiro, excepto o nome</strong>
<ul>
<li>Existe um região contínua no disco reservada para guardar todos os inodes (inode table)</li>
<li>A identificação de um inode é feita com um indíce que representa a sua posição relativa na inode table</li>
</ul></li>
<li><strong>directory</strong>: <em>special file</em> que permite a implementação de uma hierarquia (árvore) para acesso aos ficheiros
<ul>
<li>É composto por um conjunto de entradas (<em>directory entries</em>) em que cada uma associa um nome a um inode</li>
<li>Assume-se que o diretório de raiz (<em>root</em>) está associado ao inode 0</li>
</ul></li>
<li><strong>disk blocks</strong>: usados para guardar os dados
<ul>
<li>Estão organizados em grupos de 4 blocos contínuos -&gt; <strong>clusters</strong></li>
<li>A identificação de um cluster é dada através de um indíce que identifica a posição relativa do cluster na cluster zone</li>
</ul></li>
<li><strong>cluster</strong>: Para cada cluster existe um bit correspondente que representa o seu estado (vazio/preenchido)
<ul>
<li>Estes bits estão guardados no sistema de ficheiros numa área chamada <em>reference bitmpa table</em></li>
</ul></li>
</ul></li>
</ul>
<p>De forma geral, os N blocks de um disco formatado em sof17 organizam-se em 4 áreas:</p>
<div class="figure">
<img src="../Pictures/sofs17_disk.png" alt="Organização de um disco formatado em sofs17" />
<p class="caption">Organização de um disco formatado em sofs17</p>
</div>
<h2 id="list-of-free-inodes">2.1 List of free inodes</h2>
<ul>
<li>O número de inodes num disco sofs17 é <strong>fixo após a formatação</strong>.</li>
<li>Quando um novo ficheiro é criado, deve-lhe ser atribuido um inode. Para isso é preciso:
<ul>
<li>Definir uma política (conjunto de regras) para decidir que free inode será usado</li>
<li>Definir e guardar no disco uma estrutura de dados adequada à implementação desta política</li>
</ul></li>
</ul>
<hr />
<blockquote>
<p><em>In sofs17 a FIFO policy is used, meaning that the first free inode to be used is the oldest one. The implementation is based in a double linked list of free inodes, built using the inodes themselves.</em></p>
</blockquote>
<hr />
<ul>
<li>Na estrutura de inodes, existem dois campos que guardam os indíces do próximo inode e do inode anterior vazios (criam uma lista ligada)</li>
<li>Estas listas ligadas de inodes são circulares, ou seja:
<ul>
<li>O <em>previous</em> inode livre do primeiro free inode é o último free inode</li>
<li>o <em>next</em> free inode do último inode é o primeiro free inode</li>
<li>Assim:</li>
<li>Cada numero da lista paonta sempre para o seguinte.</li>
<li>O previous aponta sempre para o elemento aterior.</li>
<li>Só preciso de saber a tail porque a previous do head é a tail</li>
</ul></li>
<li>No <em>superblock</em>, dois campos guardam o número total de free inodes e um indíce para o primeiro free inode</li>
<li>O número de inodes por default é [NUM_BLOCKS]/8</li>
</ul>
<p>Correspondência univoca entre o inode e o nome do ficheiro</p>
<ul>
<li>stat <filename> : mostra a estatísticas do ficheiro (filesize, blocks, ID Block, device, inode, links e datas de aceso, modificação e change)
<ul>
<li>Ficheiro <code>.</code> : diretório atual</li>
<li>Ficheiro <code>..</code> : diretório atual</li>
</ul></li>
</ul>
<h2 id="list-of-free-clusters">2.2 List of free clusters</h2>
<ul>
<li>Tal como os inodes, o número de clusters num disco é fixo após a formatação.</li>
<li>Para manipular a estrutura de clusters é necessário:
<ul>
<li>Definir uma maneira de representar o estado (livre/usado) de todos os clusters no disco</li>
<li>Definir uma política para decidir que cluster (que estea livre) deve ser usado quanto é necessário um cluster</li>
<li>Definir e guardar no disco uma estrutura de dados adequada para representar o sistema de clusters e permitir a implementação dos pontos acima</li>
</ul></li>
</ul>
<p>Concretamente no sofs17:<br />
- Existe uma estrutura de <em>bit map</em> unívoca que mapeia o estado de um cluster - Esta estrutura é formada por um blocos contínuos no disco (logo após a <em>inode table</em>) - Cada bit funciona como uma variável booleana que classifica o cluster que referencia como vazio ou ocupado - Existem duas caches guardadas no superblock que são usadas para guardar referências diretas para os clusters. São: - <strong>retrieval cache</strong>: - <strong>insertion cache</strong>: - Considera-se que um cluster está livre nas seguintes condições - A sua referência está em qualquer uma das caches - Ou o seu bit correspondente no bit map indica que está vazio</p>
<ul>
<li>As duas caches têm como função melhorar a eficiência de operações de <strong>alocação</strong>(atribiuir um cluster livre a um novo ficheiro a ser guardado em disco) e <strong>libertação</strong>(remover as referências para um dado cluster).
<ul>
<li>Na maioria das vezes as duas operações só precisam de aceder ao superblock e não fazem mais di que um acesso ao disco</li>
</ul></li>
</ul>
<h3 id="retrieval-chache">Retrieval Chache</h3>
<p>Serve para guardar as referências após eliminar um ficheiro. Se o disco tiver vazio, a referência deve ser max e não 0. O valor 0 significa que está cheio a retrieval cach está cheia.</p>
<h3 id="insertion-cache">Insertion cache</h3>
<p>Serve para guardar as referências de ficheiros a inserir. Se o cache estiver vazia, a referência deve ser 0. O valor 0 significa que a insertion cache está cheia.</p>
<div class="figure">
<img src="../Pictures/cache.png" alt="Caches and Reference bitmap blocks" />
<p class="caption">Caches and Reference bitmap blocks</p>
</div>
<h3 id="allocation">Allocation</h3>
<ol style="list-style-type: decimal">
<li>Uma referência para um cluster livre é obtida da retrieval cache
<ol style="list-style-type: decimal">
<li>Se a cache tiver vazia, são transferidas várias referências do bit map para a cache antes de se obter a referência para o cluster livre</li>
<li>As referências transferidas para os clusters são transferidas de forma sequencial</li>
</ol></li>
<li>Um byte iglobal (guardado no superblock) indica a localização no bit map de onde a transferência deve começar
<ol style="list-style-type: decimal">
<li>Assim cria-se rotatividade no uso dos clusters</li>
</ol></li>
<li>Os clusters não funcionam estritamente como uma FIFO.
<ol style="list-style-type: decimal">
<li>Se a <em>retrieval cache</em> e o bit map estão vazios, as referências presentes na inserion cache são transferidas da insertion cache para o disco</li>
<li>Se se efetua uma release operation a referência para o novo cluster livre é inserida na inserion cache</li>
<li>Se esta cache está cheia, então as referências para a cache são transferidas para o bit map, antes de se proceder como anteriormente</li>
</ol></li>
</ol>
<h2 id="list-of-clusters-used-by-a-file-inode">2.3 List of clusters used by a file (inode)</h2>
<hr />
<blockquote>
<p><em><strong>Clusters are not shared among files, thus, an in-use cluster belongs to a single file</strong></em></p>
</blockquote>
<hr />
<p>O número de clusters usado por um ficheiro é <span class="math inline">$N_c = roundup(\frac{size}{ClusterSize})$</span>, onde:  </p>
<ul>
<li><strong>size</strong>: tamanho em bytes de um ficheiro</li>
<li><strong>ClusterSize</strong>: tamanho de um cluster em bytes</li>
</ul>
<h3 id="considerações">Considerações:</h3>
<ul>
<li><span class="math inline"><em>N</em><sub><em>c</em></sub></span> pode ser muito elevado.
<ul>
<li>Um disco com um block size de 512 bytes e com um <em>cluster size</em> de 4 blocos. Se o ficheiro a guardar tiver 2 GByte são necessários 1 milhão de clusters</li>
</ul></li>
<li><span class="math inline"><em>N</em><sub><em>c</em></sub></span> pode ser nulo (0):
<ul>
<li>Se o ficheiro tiver 0 bytes, <span class="math inline"><em>N</em><sub><em>c</em></sub></span> = 0</li>
</ul></li>
</ul>
<hr />
<blockquote>
<p><em>Thus, it is impractical that all the clusters used by a file are contiguous in disk. The data structure used to represent the sequence of clusters used by a file must be flexible, growing as necessary.</em></p>
</blockquote>
<hr />
<p>A <strong>escrita</strong> e a <strong>leitura</strong> no disco <strong>não são sequenciais</strong>, mas sim aleatórias.</p>
<p>Exemplo: pretendemos aceder ao indice <em>j</em> de um ficheiro. Para obter o cluster que contém esse ficheiro precisamos de saber o indice do cluster do ponto de vista de um ficheiro, <span class="math inline">$ClusterIndex = \frac{j}{ClusterSize}$</span></p>
<p>Para obter a localização do ficheiro no disco, temos de obter o número do cluster usando a estrutura do filesystem. e No sofs17:<br />
- a <em>data strucuture</em> definida é dinâmica e permite uam identificação rápida de qualquer data cluster. - Cada inode permite o acesso a um array dinâmico, <em><strong>d</strong></em>, que identifica a sequencia de clusters usados para guardar os dados associados com um ficheiro. - Sendo <em><strong>ClusterSize</strong></em> o tamanho em bytes de um cluster, temos:</p>
<table>
<thead>
<tr class="header">
<th align="center">Cluster</th>
<th align="left">Descrição</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">d[0]</td>
<td align="left">Número do cluster que contem os primeiros ClusterSize bytes</td>
</tr>
<tr class="even">
<td align="center">d[1]</td>
<td align="left">Número do cluster que contem os segundos ClusterSize bytes</td>
</tr>
<tr class="odd">
<td align="center">.</td>
<td align="left">…</td>
</tr>
<tr class="even">
<td align="center">.</td>
<td align="left">…</td>
</tr>
<tr class="odd">
<td align="center">d[<span class="math inline"><em>N</em><sub><em>c</em></sub> − 1</span>]</td>
<td align="left">Número do cluster que contém os últimos ClusterSize bytes</td>
</tr>
</tbody>
</table>
<p>O array <em><strong>d</strong></em> não é guardado num único local:<br />
- Os <strong>primeiros 6 elementos</strong> são diretamente guardados no inode, no campo d (referência direta) - Os <strong>próximos elementos, se existirem, são referenciados através dos campos: - </strong><span class="math inline"><em>i</em><sub>1</sub></span><strong>: referência indireta - </strong><span class="math inline"><em>i</em><sub>2</sub></span>**: referªencia indireta dupla</p>
<h3 id="campo-i_1">Campo <span class="math inline"><em>i</em><sub>1</sub></span></h3>
<ul>
<li>É usado para estender indiretamente o array <em><strong>d</strong></em></li>
<li>O primeiro elemento, <span class="math inline"><em>i</em><sub>1</sub>[0]</span> é usado para referenciar um cluster onde cada bloco é um endereço para uma posição no disco (cluster) onde estão guardados os dados do ficheiro</li>
<li>Permite extender o array d de d[6] para d[RPC+6-1]=d[RPC+5]
<ul>
<li><strong>RPC</strong> é o número de referências para clusters que podem ser guardadas num cluster</li>
</ul></li>
</ul>
<h3 id="campo-i_2">Campo <span class="math inline"><em>i</em><sub>2</sub></span></h3>
<ul>
<li>Se mesmo assim não for possível guardar os dados do ficheiro usando referência indireta simples, pode ser usada referência indireta dupla.</li>
<li>O campo <span class="math inline"><em>i</em><sub>2</sub></span> do inode é usado para referenciar um cluster em que cada bloco do cluster referenciad um cluster de dados</li>
<li>É usado para extender o array de referências indiretas <span class="math inline"><em>i</em><sub>1</sub></span> usando as referências indiretas do cluster. Assim temos um array de referências indiretas de <span class="math inline"><em>i</em><sub>1</sub>[1]</span> até <span class="math inline"><em>i</em><sub>1</sub>[<em>R</em><em>P</em><em>C</em>]</span>.</li>
<li>O primeiro cluster do array de referências indiretas duplas é <span class="math inline"><em>i</em><sub>1</sub>[1]</span> (<span class="math inline"><em>i</em><sub>1</sub>[0]</span> corresponde às referências diretas).
<ul>
<li>Traduzindo para o array de <strong><em>d</em></strong> corresponde aos segmentos do array entre d[RPC + 6] e <span class="math inline"><em>d</em>[2 * <em>R</em><em>P</em><em>C</em> + 5]</span></li>
</ul></li>
</ul>
<h3 id="nullreference">NullReference</h3>
<ul>
<li>É usada para representar uma referência que não existe</li>
<li>Exemplos:
<ul>
<li>se d[1] for uma NullReference, o ficheiro não contém o index de cluster 1</li>
<li>se <span class="math inline"><em>i</em><sub>1</sub></span>, representando <span class="math inline"><em>i</em><sub>1</sub>[0]</span> é equal to NullReference, significa que entre d[6] até d[RPC+5] todos os indices são NullReference e o o ficheiro não contém estes indices</li>
<li>se <span class="math inline"><em>i</em><sub>2</sub></span> for uma NullReference, significa que entre <span class="math inline"><em>i</em><sub>1</sub>[1]</span> to <span class="math inline"><em>i</em><sub>1</sub>[<em>R</em><em>P</em><em>C</em>]</span> são NullReferences e portanto d[RPC+6] até d[RPC^2 + RPC+ 5] são NullReferences e o ficheiro não contém esses indices</li>
</ul></li>
</ul>
<h2 id="directories">2.4 Directories</h2>
<ul>
<li>Um diretório pode ser visto como um array de entrada para diretórios.</li>
<li>No sofs17:
<ul>
<li>Um diretório é uma estrutura de dados composta por um array de bytes com tamanho fixo. Usados para guardar:
<ul>
<li>nome</li>
<li>referência que associa o diretório a um inode</li>
</ul></li>
<li>A estrutura de dados foi definida para que um cluster suporte apenas um número inteiro de diretórios
<ul>
<li>As primeiras duas entradas <code>&quot;.&quot;</code> e <code>&quot;..&quot;</code> representam o diretório atual e o diretório pai</li>
<li>Um diretório pode tomar um de três estados:
<ul>
<li><strong>in-use</strong>: contém o nome e o inode number de um ficheiro que existe (seja ele um regular file, diretório ou atalho)</li>
<li><strong>deleted</strong>: o nome contém o 1 e último caracter trocado, passando a ser <code>\0 name[0:end-1]</code> (ou seja, uma null string, mas com o nome recuperável). Mantém o slot no diretório.</li>
<li><strong>clean</strong>: Todos os caracteres do nome são <code>\0</code> e o reference field é uma NullReference</li>
</ul></li>
</ul></li>
<li>Quando um cluster é adicionado a um diretório, primeiro deve formatado como uma sequência de diretórios de entrada limpas.
<ul>
<li>O tamanho do diretório é sempre um múltiplo do tamanho de um cluster e nunca pode “encolher” (devido à forma como o delete está implementado</li>
</ul></li>
</ul></li>
</ul>
<h1 id="formatting">3. Formatting</h1>
<p>A operação de formatação deve preencher todos os blocos do disco para criar um disco sofs17 vazio.</p>
<p>Um disco formatado contém:<br />
- root directory<br />
- duas entradas, <code>&quot;.&quot;</code> e <code>&quot;..&quot;</code>, que apontam para o inode 0 (root directory)</p>
<p>A operação de formatação deve:  </p>
<ul>
<li>escolher o valor apropriado para o número de inodes, o número de clusters e o número de blocos usados pelo bit map
<ul>
<li>tem de ter em consideração o número de inodes especificado pelo utilizador e número total de blocos no disco.</li>
<li>todos os blocos no disco devem ser usados. Se não forem usados para outros propósitos devem ser adicionados à inode table</li>
</ul></li>
<li>Preencher a tabela de inodes:
<ul>
<li>inode number 0 é o root directory</li>
<li>todos os outros inodes estão livres</li>
<li>A lista de inodes livres começa no inode número 1 e termina no último inode</li>
</ul></li>
<li>Preencher o bit map, sabendo que:
<ul>
<li>O cluster 0 está a ser usado pelo diretório root</li>
<li>Todos os outros clusters estão livres</li>
</ul></li>
<li>Preencher o root directory, ocupando o cluster número 0</li>
<li>Preencher com zeros todos os clusters livres, se especificado pela ferramenta de formatação</li>
</ul>
<h1 id="code-structure">4. Code Structure</h1>
<p>A estrutura do código é apresentada abaixo:</p>
<div class="figure">
<img src="../Pictures/structure.png" alt="Code Strucuture to be developed" />
<p class="caption">Code Strucuture to be developed</p>
</div>
<h2 id="rawdisk">Rawdisk</h2>
<p>Implementa o acesso físico ao disco</p>
<h2 id="dealers">Dealers</h2>
<ul>
<li>Implementam o acesso ao superblock, inodes, bit map e clusters</li>
<li>São opcionais (só são feitas se os alunos desejarem ter notas mais altas)</li>
</ul>
<h3 id="sbdealer">sbdealer</h3>
<p>Acesso ao superblock</p>
<h3 id="itdealer">itdealer</h3>
<p>Acesso à inode table e aos inodes</p>
<h3 id="bmdealer">bmdealer</h3>
<p>Acesso às referências da bit map table</p>
<h3 id="czdealer">czdealer</h3>
<p>Acesso à cluster zone, usando as cluster references</p>
<h3 id="ocdelaer">ocdelaer</h3>
<p>Open/close the dealers</p>
<h2 id="ilayers">ilayers</h2>
<p>Funções intermédias Obrigatórias</p>
<h3 id="inodeattr">inodeattr</h3>
<p>Lida com a manipulação dos campos especiais dos inodes</p>
<h3 id="freelists">freelists</h3>
<p>Manipular a lista dos inodes livres e a lista de clusters livres</p>
<h3 id="filecluster">filecluster</h3>
<p>Lidar com os clusters de um inode (file clusters associados a um ficheiro)</p>
<h3 id="direntries">direntries</h3>
<p>Lidar com entradas de diretórios</p>
<h2 id="syscalls">syscalls</h2>
<p>versão das syscalls de sistema adaptadas ao <em>sofs17</em> Cada grupo Só irá implementar 6 das 24 utilizadas.</p>
<h2 id="fusecallbacks">fusecallbacks</h2>
<p>Interface com FUSE</p>
<h2 id="probing">probing</h2>
<p>Biblioteca para debug</p>
<h2 id="exception">exception</h2>
<p>o tipo de exceções lançadas em caso de erro</p>
<ul>
<li><strong>datatypes</strong>: um conjunto de constantes que podem ser usadas para aceder aos ficheiros
<ul>
<li>InodesPerBlock</li>
<li>ReferencesPerBlock</li>
<li>ReferencesPerCluster</li>
<li>ReferencesPerBitmapBlock</li>
<li>BlocksPerCluster</li>
<li>CLusterSize</li>
<li>DirentriesPerCluster</li>
<li>NullReference</li>
</ul></li>
</ul>
<h1 id="createdisk">createDisk</h1>
<ul>
<li>Cria um disco <strong>não formatado</strong> que serve de suporte a um sistema de ficheiros.</li>
<li><p>Na prática, um disco é um ficheiro que possui uma estrutura de blocos fixa.</p></li>
<li>Apenas é garantida que a estrutura do disco possui:
<ul>
<li>o número desejado de clusters</li>
<li>o número desejado de bytes por cluster</li>
</ul></li>
<li><p>Para o disco ser um sistema de ficheiros válido é necessário formatá-lo com ferramentas adequadas para o tipo de sistemas de ficheiros pretendido</p></li>
</ul>
<h2 id="exemplo-de-utilização">Exemplo de utilização</h2>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./createDisk</span> <span class="op">&lt;</span>diskfile<span class="op">&gt;</span> <span class="op">&lt;</span>numblocks<span class="op">&gt;</span></code></pre></div>
<p>O <em>output</em> após a execução do script para um disco com 1000 blocos é:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./createDisk</span> <span class="op">&lt;</span>diskfle<span class="op">&gt;</span> 1000
<span class="ex">1000+0</span> records in                               
<span class="ex">1000+0</span> records out
<span class="ex">512000</span> bytes (512 kB) <span class="ex">copied</span>, 0.05734 s, 8.9 MB/s</code></pre></div>
<h2 id="implementação">Implementação</h2>
<p>O createDisk usa o comando <a href="https://en.wikipedia.org/wiki/Dd_(Unix)" title="Wikipedia page"><em>dd</em></a> para escrever para o disco/ficheiro e preenche-o com valores aleatórios obtidos do <em>/dev/urandom</em>.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#!/bin/bash                </span>
           
<span class="kw">if</span><span class="bu"> [</span> <span class="va">$#</span> <span class="ot">!=</span> 2<span class="bu"> ]</span>; <span class="kw">then</span>
        <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">$0</span><span class="st"> diskfile numblocks&quot;</span>
        <span class="bu">exit</span> 1                     
<span class="kw">fi</span>
 
<span class="fu">dd</span> if=/dev/urandom of=<span class="va">$1</span> bs=512 count=<span class="va">$2</span></code></pre></div>
<h1 id="showblock">showblock</h1>
<ul>
<li>Permite visualizar a informação contida numa sequência de blocos do disco:
<ul>
<li>Os dados dos blocos podem ser formatados para serem facilmente interpretáveis por humanos</li>
<li>A formatação dos dados dos blocos pode ser feita de acordo com a função de cada um dos blocos</li>
</ul></li>
</ul>
<h2 id="utilização">Utilização</h2>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># showblock -h imprime a ajuda</span>
<span class="ex">./showblock</span> [ OPTION ] <span class="op">&lt;</span>disk filename<span class="op">&gt;</span></code></pre></div>
<h3 id="opções-de-visualização">Opções de Visualização</h3>
<table>
<thead>
<tr class="header">
<th align="center">Option</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">-x</td>
<td align="left">show block(s) as hexadecimal data</td>
</tr>
<tr class="even">
<td align="center">-a</td>
<td align="left">show block(s) as ascii/hexadecimal data</td>
</tr>
<tr class="odd">
<td align="center">-s</td>
<td align="left">show block(s) as superblock data</td>
</tr>
<tr class="even">
<td align="center">-i</td>
<td align="left">show block(s) as inode entries</td>
</tr>
<tr class="odd">
<td align="center">-d</td>
<td align="left">show block(s) as directory entries</td>
</tr>
<tr class="even">
<td align="center">-r</td>
<td align="left">show block(s) as cluster references</td>
</tr>
<tr class="odd">
<td align="center">-b</td>
<td align="left">show block(s) as bitmap references</td>
</tr>
</tbody>
</table>
<h2 id="exemplos">Exemplos</h2>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># Showblock para o bloco 1 em hexadecimal</span>
<span class="ex">./showblock</span> -x 1 disk.sofs17
<span class="ex">0000</span>: fd 41 02 00 e8 03 00 00 e8 03 00 00 00 08 00 00 01 00 00 00 dc ee f9 59 dc ee f9 59 dc ee f9 59
<span class="ex">0020</span>: 00 00 00 00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">0040</span>: 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 02 00 00 00 8f 00 00 00
<span class="ex">0060</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">0080</span>: 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03 00 00 00 01 00 00 00
<span class="ex">00a0</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">00c0</span>: 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 02 00 00 00
<span class="ex">00e0</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">0100</span>: 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 05 00 00 00 03 00 00 00
<span class="ex">0120</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">0140</span>: 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 00 00 00 04 00 00 00
<span class="ex">0160</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">0180</span>: 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 07 00 00 00 05 00 00 00
<span class="ex">01a0</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">01c0</span>: 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 00 00 00 06 00 00 00
<span class="ex">01e0</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff

<span class="co"># A informação não é diretamente percetível por humanos. </span>
<span class="co"># Sabendo que este bloco corresponde ao primeiro bloco da inode table, </span>
<span class="co"># se executarmos o mesmo comando mas o output vier formatado para inodes, temos:</span>
<span class="ex">./showblock</span> -i 1 disk.sofs17
<span class="ex">Inode</span> <span class="co">#0</span>
<span class="bu">type</span> =  directory, permissions = rwxrwxr-x, lnkcnt = 2, owner = 1000, group = 1000
<span class="fu">size</span> in bytes = 2048, size in clusters = 1
<span class="ex">atime</span> = Wed Nov  1 15:57:16 2017, mtime = Wed Nov  1 15:57:16 2017, ctime = Wed Nov  1 15:57:16 2017
<span class="ex">d</span>[] = {0 (nil) <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span>}, <span class="ex">i1</span> = (nil), <span class="ex">i2</span> = (nil)
<span class="ex">----------------</span>
<span class="ex">Inode</span> <span class="co">#1</span>
<span class="bu">type</span> = free clean, permissions = ---------, lnkcnt = 0, owner = 0, group = 0
<span class="fu">size</span> in bytes = 0, size in clusters = 0
<span class="ex">next</span> = 2, , prev = 143
<span class="ex">d</span>[] = {(nil) <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span>}, <span class="ex">i1</span> = (nil), <span class="ex">i2</span> = (nil)
<span class="ex">----------------</span>
<span class="ex">Inode</span> <span class="co">#2</span>
<span class="bu">type</span> = free clean, permissions = ---------, lnkcnt = 0, owner = 0, group = 0
<span class="fu">size</span> in bytes = 0, size in clusters = 0
<span class="ex">next</span> = 3, , prev = 1
<span class="ex">d</span>[] = {(nil) <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span>}, <span class="ex">i1</span> = (nil), <span class="ex">i2</span> = (nil)
<span class="ex">----------------</span>
<span class="ex">Inode</span> <span class="co">#3</span>
<span class="bu">type</span> = free clean, permissions = ---------, lnkcnt = 0, owner = 0, group = 0
<span class="fu">size</span> in bytes = 0, size in clusters = 0
<span class="ex">next</span> = 4, , prev = 2
<span class="ex">d</span>[] = {(nil) <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span>}, <span class="ex">i1</span> = (nil), <span class="ex">i2</span> = (nil)
<span class="ex">----------------</span>
<span class="ex">Inode</span> <span class="co">#4</span>
<span class="bu">type</span> = free clean, permissions = ---------, lnkcnt = 0, owner = 0, group = 0
<span class="fu">size</span> in bytes = 0, size in clusters = 0
<span class="ex">next</span> = 5, , prev = 3
<span class="ex">d</span>[] = {(nil) <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span>}, <span class="ex">i1</span> = (nil), <span class="ex">i2</span> = (nil)
<span class="ex">----------------</span>
<span class="ex">Inode</span> <span class="co">#5</span>
<span class="bu">type</span> = free clean, permissions = ---------, lnkcnt = 0, owner = 0, group = 0
<span class="fu">size</span> in bytes = 0, size in clusters = 0
<span class="ex">next</span> = 6, , prev = 4
<span class="ex">d</span>[] = {(nil) <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span>}, <span class="ex">i1</span> = (nil), <span class="ex">i2</span> = (nil)
<span class="ex">----------------</span>
<span class="ex">Inode</span> <span class="co">#6</span>
<span class="bu">type</span> = free clean, permissions = ---------, lnkcnt = 0, owner = 0, group = 0
<span class="fu">size</span> in bytes = 0, size in clusters = 0
<span class="ex">next</span> = 7, , prev = 5
<span class="ex">d</span>[] = {(nil) <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span>}, <span class="ex">i1</span> = (nil), <span class="ex">i2</span> = (nil)
<span class="ex">----------------</span>
<span class="ex">Inode</span> <span class="co">#7</span>
<span class="bu">type</span> = free clean, permissions = ---------, lnkcnt = 0, owner = 0, group = 0
<span class="fu">size</span> in bytes = 0, size in clusters = 0
<span class="ex">next</span> = 8, , prev = 6
<span class="ex">d</span>[] = {(nil) <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">nil</span><span class="kw">)</span>}, <span class="ex">i1</span> = (nil), <span class="ex">i2</span> = (nil)
<span class="ex">----------------</span></code></pre></div>
<h1 id="rawlevel">rawlevel</h1>
<ul>
<li>Camada que permite a manipulação do disco ao nível do bloco</li>
</ul>
<h2 id="módulos">Módulos</h2>
<ul>
<li><strong>mksofs</strong> : Formatador</li>
<li><strong>rawdisk</strong> : Acesso aos blocos do disco</li>
</ul>
<h1 id="rawdisk-1">rawdisk</h1>
<ul>
<li>Permite o acesso aos blocos do disco
<ul>
<li>Os blocos são a menor unidade lógica no <em>filesystem</em></li>
</ul></li>
<li>Medeia o acesso direto ao disco, impedindo que ocorram erros que podem danificar a estrutura do sistema de ficheiros</li>
</ul>
<h2 id="macros">Macros</h2>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// block size (in bytes)</span>
<span class="pp">#define BlockSize (512U)</span></code></pre></div>
<h2 id="funções">Funções</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> soOpenRawDisk (<span class="at">const</span> <span class="dt">char</span> *devname, <span class="dt">uint32_t</span> *np=NULL)</code></pre></div>
<ul>
<li>Abre o dispositivo de armazenamento, criando um canal de comunicação com esse dispositivo
<ul>
<li>Supoem que o dispositivo está fechado e mais nenhum canal de comunicação para esse dispositivo está aberto</li>
<li>O dispositivo de armazenamento tem de existir</li>
<li>O dispositivo de armazenamento tem de ter um tamanho múltiplo do block size</li>
</ul></li>
</ul>
<h3 id="section"></h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> soCloseRawDisk (<span class="dt">void</span>) </code></pre></div>
<ul>
<li>Fecha o dispositivo de armazenamento e o canal de comunicação.</li>
</ul>
<h3 id="section-1"></h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> soReadRawBlock(<span class="dt">uint32_t</span> n, <span class="dt">void</span> *buf)  </code></pre></div>
<ul>
<li>Lê um bloco de dados do dispositivo</li>
<li><strong>Parametros:</strong>
<ul>
<li><em>n</em>: número físico do bloco de dados no disco de onde a informação vai ser lida</li>
<li><em>buf</em>: ponteiro para o buffer para onde os dados vão ser lidos</li>
</ul></li>
</ul>
<h3 id="section-2"></h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> soWriteRawBlock ( <span class="dt">uint32_t</span>  n, <span class="dt">void</span> * buf)</code></pre></div>
<ul>
<li>Escreve um bloco de dados do dispositivo</li>
<li><strong>Parametros:</strong>
<ul>
<li><em>n</em>: número físico do bloco de dados no disco onde a informação vai ser escrita</li>
<li><em>buf</em>: ponteiro para o buffer que contém os dados a ser escritos # msksofs</li>
</ul></li>
<li>Script responsável por formatar o disco</li>
<li>Cria um disco utilizável
<ul>
<li>Manipula os blocos do disco para implementar o <em>sofs17 filesystem</em></li>
</ul></li>
</ul>
<h2 id="utilização-1">Utilização</h2>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">USAGE</span>:
<span class="ex">Sinopsis</span>: mksofs [OPTIONS] supp-file
  <span class="ex">OPTIONS</span>:
  <span class="ex">-n</span> name --- set volume name (default: <span class="st">&quot;sofs17_disk&quot;</span>)
  <span class="ex">-i</span> num  --- set number of inodes (default: N/8, where N = number of blocks)
  <span class="ex">-z</span>      --- set zero mode (default: not zero)
  <span class="ex">-q</span>      --- set quiet mode (default: not quiet)
  <span class="ex">-h</span>      --- print this help</code></pre></div>
<ul>
<li>Posso usar mais do que uma das opções na mesma execução ## Exemplos</li>
</ul>
<h3 id="no-options">No Options</h3>
<ul>
<li>Basta indicar o número do ficheiro</li>
<li>Por default, o número de inodes é o número de clusters/8</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./mksofs</span> ../disk.sofs17

<span class="ex">Trying</span> to install a 125-inodes SOFS17 file system in ../disk.sofs17.
<span class="ex">Computing</span> disk structure... 
<span class="ex">Filling</span> in the superblock fields... 
<span class="ex">Filling</span> in the table of inodes... 
<span class="ex">Filling</span> in the bitmap of free clusters... 
<span class="ex">Filling</span> in the root directory... 
<span class="ex">144-inodes</span> SOFS17 file system was successfully installed in ../disk.sofs17.</code></pre></div>
<h3 id="set-name">Set name</h3>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">./mksofs.bin64</span> disk.sofs17 -n <span class="st">&quot;my disk&quot;</span>

<span class="ex">Trying</span> to install a 125-inodes SOFS17 file system in disk.sofs17.
  <span class="ex">Computing</span> disk structure... done.
  <span class="ex">Filling</span> in the superblock fields... done.
  <span class="ex">Filling</span> in the table of inodes... done.
  <span class="ex">Filling</span> in the bitmap of free clusters... done.
  <span class="ex">Filling</span> in the root directory... done.
<span class="ex">A</span> 144-inodes SOFS17 file system was successfully installed in disk.sofs17.

$ <span class="ex">./showblock</span> disk.sofs17 -s 0
<span class="ex">Header</span>:
   <span class="ex">Magic</span> number: 0x50F5
   <span class="ex">Version</span> number: 0x2017
   <span class="ex">Volume</span> name: my disk
   <span class="ex">Properly</span> unmounted: yes
   <span class="ex">Number</span> of mounts: 0
   <span class="ex">Total</span> number of blocks in the device: 1000
<span class="ex">Inode</span> table metadata:
   <span class="ex">First</span> block of the inode table: 1
   <span class="kw">(</span><span class="ex">...</span><span class="kw">)</span></code></pre></div>
<h3 id="set-inodes">Set inodes</h3>
<ul>
<li>O formatador tenta formatar o disco para o número desejado de inodes</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./mksofs.bin64</span> disk.sofs17 -i 2000

<span class="ex">Trying</span> to install a 2000-inodes SOFS17 file system in disk.sofs17.
  <span class="ex">Computing</span> disk structure... done.
  <span class="ex">Filling</span> in the superblock fields... done.
  <span class="ex">Filling</span> in the table of inodes... done.
  <span class="ex">Filling</span> in the bitmap of free clusters... done.
  <span class="ex">Filling</span> in the root directory... done.
<span class="ex">A</span> 2000-inodes SOFS17 file system was successfully installed in disk.sofs17.</code></pre></div>
<ul>
<li>Pode não ser possível formatar o disco para o número desejado de inodes</li>
<li>Nesse caso, o formatador usa o número de inodes possível imediatamente superior ao pretendido</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./mksofs.bin64</span> disk.sofs17 -i 100

<span class="ex">Trying</span> to install a 100-inodes SOFS17 file system in disk.sofs17.
  <span class="ex">Computing</span> disk structure... done.
  <span class="ex">Filling</span> in the superblock fields... done.
  <span class="ex">Filling</span> in the table of inodes... done.
  <span class="ex">Filling</span> in the bitmap of free clusters... done.
  <span class="ex">Filling</span> in the root directory... done.
<span class="ex">A</span> 112-inodes SOFS17 file system was successfully installed in disk.sofs17.</code></pre></div>
<h3 id="zero-mode">Zero Mode</h3>
<ul>
<li>Ao usar a opção <code>-z</code> todos os clusters livres são preenchidos com zeros</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./mksofs</span> ../disk.sofs17 -z

<span class="ex">Trying</span> to install a 125-inodes SOFS17 file system in ../disk.sofs17.
<span class="ex">Computing</span> disk structure... 
<span class="ex">Filling</span> in the superblock fields... 
<span class="ex">Filling</span> in the table of inodes... .
<span class="ex">Filling</span> in the bitmap of free clusters... 
<span class="ex">Filling</span> in the root directory... 
<span class="ex">Filling</span> in free clusters with zeros... cstart: 24, ctotal: 244
<span class="ex">A</span> 144-inodes SOFS17 file system was successfully installed in ../disk.sofs17.</code></pre></div>
<h1 id="computestruture">computeStruture</h1>
<ul>
<li>Calcula a divisão da estruturas no disco
<ul>
<li>número de clusters</li>
<li>número de blocos para inodes</li>
<li>número de blocos para reference map</li>
</ul></li>
<li></li>
</ul>
<h2 id="algoritmo">Algoritmo</h2>
<ul>
<li>No mínimo têm de existir 6 blocos no disco
<ul>
<li>1 superblock</li>
<li>0 inodes</li>
<li>1 reference map</li>
<li>1 cluster de dados</li>
</ul></li>
<li>Por default o número de inodes é <span class="math inline">$N_{inodes} = \frac{N_{clusters}}{8}$</span></li>
<li>Caso o número de inodes não seja divisível por 8, é preciso alocar mais um bloco para os inodes</li>
<li>O número temporário de blocos livres (falta o reference map) é: <br /><span class="math display"><em>N</em><sub><em>b</em><em>l</em><em>o</em><em>c</em><em>o</em><em>s</em><em>d</em><em>i</em><em>s</em><em>c</em><em>o</em></sub> − <em>N</em><sub><em>b</em><em>l</em><em>o</em><em>c</em><em>o</em><em>s</em><em>i</em><em>n</em><em>o</em><em>d</em><em>e</em><em>s</em></sub> − 1</span><br />
<ul>
<li>o ‘1’ corresponde ao superblock</li>
</ul></li>
<li>O número de clusters é o resultado da divisão do número de blocos livres pelo número de blocos por cluster</li>
<li>Através do número de clusters pode ser estimado o número de blocos necessários para a reference map</li>
<li>Depois dessa estimativa é possível calcular o número de blocos restantes e atribuí-los à inode table</li>
</ul>
<h2 id="utilização-2">Utilização</h2>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> computeStructure(  <span class="dt">uint32_t</span>    ntotal,
                        <span class="dt">uint32_t</span>    itotal,
                        <span class="dt">uint32_t</span> *  itsizep,
                        <span class="dt">uint32_t</span> *  rmsizep,
                        <span class="dt">uint32_t</span> *  ctotalp 
                     )      </code></pre></div>
<h3 id="parameters">Parameters</h3>
<ul>
<li><strong>ntotal:</strong> total number of blocks of the device</li>
<li><strong>itotal:</strong> requested number of inodes</li>
<li><strong>itsizep:</strong> pointer to mem where to store the size of inode table in blocks</li>
<li><strong>rmsizep:</strong> pointer to mem where to store the size of cluster reference table in blocks</li>
<li><strong>ctotalp:</strong> pointer to mem where to store the number of clusters</li>
</ul>
<h2 id="testes">Testes</h2>
<h3 id="blocos-125-inodes-nblocos8">1000 blocos, 125 inodes (nblocos/8)</h3>
<ul>
<li>Começamos por calcular o número de blocos necessários para os inodes
<ul>
<li>Existem 8 inodes por bloco</li>
</ul></li>
</ul>
<pre><code>125 / 8 
120   15
  5</code></pre>
<ul>
<li>Obtemos 15 blocos para inodes</li>
<li>E 5 blocos que sobram</li>
<li>Se permitimos que 4 sejam usados para um cluster, temos 16 inodes</li>
<li><p>O número de clusters é <span class="math inline">1000<em>b</em><em>l</em><em>o</em><em>c</em><em>o</em><em>s</em> − 16<em>i</em><em>n</em><em>o</em><em>d</em><em>e</em><em>s</em> − 1<em>s</em><em>u</em><em>p</em><em>e</em><em>r</em><em>b</em><em>l</em><em>o</em><em>c</em><em>k</em> = 983<em>b</em><em>l</em><em>o</em><em>c</em><em>o</em><em>s</em></span></p></li>
<li><p>O número de clusters para dados é:</p>
<pre><code>983 / 4 
980   245
  3  </code></pre></li>
<li>Passamos a ter um sistema de ficheiros <span class="math inline">15 + 3 = 18<em>b</em><em>l</em><em>o</em><em>c</em><em>o</em><em>s</em><em>p</em><em>a</em><em>r</em><em>a</em><em>i</em><em>n</em><em>o</em><em>d</em><em>e</em><em>s</em></span>
<ul>
<li>Isto equivale a ter <span class="math inline">18 × 8 = 144<em>i</em><em>n</em><em>o</em><em>d</em><em>e</em><em>s</em></span> e não os 125 como inicialmente se desejava</li>
</ul></li>
</ul>
<h1 id="fillinsuperblock">fillInSuperBlock</h1>
<ul>
<li>Preenche os campos dos superblock</li>
<li>O <em>magic number</em> deve ser 0xFFFF</li>
<li>As caches estão no <em>superblock</em></li>
</ul>
<h2 id="algoritmo-1">Algoritmo</h2>
<ul>
<li>Atribuições a serem feitas:
<ul>
<li>o magic number (identifica se o sistema é Big-Endian ou Little-Endian)</li>
<li><em>version number</em></li>
<li>nome do disco
<ul>
<li>Tem de ser truncado caso ultrapasse o <em>PARTITION_NAME_SIZE</em></li>
</ul></li>
<li>Número total de blocos</li>
</ul></li>
<li>Indicar que o disco ainda está unmounted</li>
<li>Reset ao número de mounts</li>
<li>Inode table metadata
<ul>
<li><strong>itstart:</strong> Bloco onde começa a tabela de inodes</li>
<li><strong>itsize:</strong> Número de blocos da inode table</li>
<li><strong>itotal:</strong> Número total de inodes</li>
<li><strong>ifree:</strong> Número de inodes livres</li>
<li><strong>ihead:</strong> Índice para a head do primeiro inode</li>
</ul></li>
<li>Free Cluster table metadata
<ul>
<li><strong>rmstart:</strong> bloco onde começa a reference map</li>
<li><strong>rmsize:</strong> número de blocos usados pela reference table</li>
<li><strong>rmidx:</strong> Primeira referência (<em>root dir</em>)</li>
</ul></li>
<li>Clusters metadata
<ul>
<li><strong>czstart:</strong> bloco onde começa a cluster zone</li>
<li><strong>ctotal:</strong> número total de clusters</li>
<li><strong>cfree:</strong> número de clusters livres</li>
</ul></li>
<li>Retrieval cache
<ul>
<li>Inicializar com NullReferences</li>
<li>idx -&gt; última posição da cache</li>
</ul></li>
<li>Insertion cache
<ul>
<li>Inicializar com NullReferences</li>
<li>idx -&gt; primeira posição da cache</li>
</ul></li>
</ul>
<h2 id="utilização-3">Utilização</h2>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> fillInSuperBlock(  <span class="dt">const</span> <span class="dt">char</span> * name,
                        <span class="dt">uint32_t</span>     ntotal,
                        <span class="dt">uint32_t</span>     itsize,
                        <span class="dt">uint32_t</span>     rmsize 
                     )      </code></pre></div>
<h3 id="parameters-1">Parameters</h3>
<ul>
<li><strong>name:</strong> volume name</li>
<li><strong>ntotal:</strong> the total number of blocks in the device</li>
<li><strong>itsize:</strong> the number of blocks used by the inode table</li>
<li><strong>rmsize:</strong> the number of blocks used by the cluster reference table</li>
</ul>
<h1 id="fillininodetable">fillInInodeTable</h1>
<ul>
<li>Preenche os blocos da inode table</li>
<li>O inode <strong>0</strong> deve ser preenchido considerando que está a ser usado pelo diretório raiz</li>
<li>Todos os outros inodes estão livres</li>
</ul>
<h2 id="algoritmia">Algoritmia</h2>
<ul>
<li>Para cada bloco da inode table
<ul>
<li>Criar a lista biligada</li>
<li>Referências para os clusters:
<ul>
<li>Preencher com NullReference as <em>direct references (d)</em></li>
<li>Preencher com NullReference as <em>indirect references (i1)</em></li>
<li>Preencher com NullReference as <em>double direct references (i2)</em></li>
</ul></li>
</ul></li>
<li>Inicializar o inode da root directory (<em>inode 0</em>)
<ul>
<li><strong>mode:</strong> permissões</li>
<li><strong>lnkcnt:</strong> link count - número de caminhos que chegam a este (2: <code>., ..</code>)</li>
<li><strong>owner:</strong></li>
<li><strong>group:</strong></li>
<li><strong>size:</strong> Tamanho do inode (1 cluster)</li>
<li><strong>clucnt:</strong> file size in bytes</li>
<li>Modificar access times</li>
<li>Apontar para o root dir usando as referências diretas (_d[0])</li>
</ul></li>
</ul>
<h2 id="utilização-4">Utilização</h2>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> fillInInodeTable(  <span class="dt">uint32_t</span> itstart,
                        <span class="dt">uint32_t</span> itsize 
                     )      </code></pre></div>
<h3 id="parameters-2">Parameters</h3>
<ul>
<li><strong>itstart:</strong> physical number of the first block used by the inode table</li>
<li><strong>itsize:</strong> number of blocks of the inode table</li>
</ul>
<h1 id="fillinfreeclustertable">fillInFreeClusterTable</h1>
<ul>
<li>Preeche a Free Cluster Table:
<ul>
<li>Estrutura que indica se os clusters estão livres ou ocupados</li>
</ul></li>
<li>Existe uma correspondência unívoca entre bits na <em>reference cluster table</em> e clusters no disco</li>
<li>Os bits na tabela de referências crescem da:
<ul>
<li>Lower blocks to upper blocks</li>
<li>Lower bytes to upper bytes</li>
<li>Most Significant Bytes (MSB) to Least Significant Bytes (LSB)</li>
</ul></li>
<li>Assim, o bit ‘0’ corresponde ao bit mais significativo do primeiro byte do primeiro bloco da tabela de bitmap</li>
<li>Valor do bit:
<ul>
<li><strong>‘1’:</strong> Cluster Livre</li>
<li><strong>‘0’:</strong> Cluster Ocupado</li>
</ul></li>
<li>Em geral, o número de bits na tabela é maior que o número de clutsers
<ul>
<li>Os bits não usados (ou seja, que não correspondem ao estado de nenhum cluster) devem ser inicializados como se fosse usados</li>
</ul></li>
<li>Pode existir mais do que um bloco para a reference map table</li>
</ul>
<h2 id="algoritmo-2">Algoritmo</h2>
<ul>
<li>Começa-se por definir algumas constantes:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#define CLUSTER_IN_USE 0</span>
<span class="pp">#define CLUSTER_FREE   1</span>

<span class="pp">#define BYTE_FREE   0xFF</span>
<span class="pp">#define BYTE_IN_USE 0x00</span>

<span class="pp">#define ROOT_DIR_MAP_MASK 0x7F</span></code></pre></div>
<ul>
<li>Calcula-se:
<ul>
<li>Número de Clusters que não ficam referenciados num bloco completo <br /><span class="math display"><em>n</em><em>E</em><em>x</em><em>t</em><em>r</em><em>a</em><em>C</em><em>l</em><em>u</em><em>s</em><em>t</em><em>e</em><em>r</em><em>s</em> = <em>c</em><sub><em>t</em><em>o</em><em>t</em><em>a</em><em>l</em></sub>%<em>R</em><em>e</em><em>f</em><em>e</em><em>r</em><em>e</em><em>n</em><em>c</em><em>e</em><em>s</em><em>P</em><em>e</em><em>r</em><em>B</em><em>i</em><em>t</em><em>m</em><em>a</em><em>p</em><em>B</em><em>l</em><em>o</em><em>c</em><em>k</em></span><br /></li>
<li>Número de Clusters da reference zone que estão totalmente ocupados <br /><span class="math display">$$nFullRefBlocks = \frac{c_{total}}{ReferencesPerBitmapBlock}$$</span><br /></li>
<li>Número de Blocos para a Reference Bitmap zone <br /><span class="math display"><em>n</em><em>R</em><em>e</em><em>f</em><em>B</em><em>l</em><em>o</em><em>c</em><em>k</em><em>s</em> = <em>n</em><em>F</em><em>u</em><em>l</em><em>l</em><em>R</em><em>e</em><em>f</em><em>B</em><em>l</em><em>o</em><em>c</em><em>k</em><em>s</em> + (<em>n</em><em>E</em><em>x</em><em>t</em><em>r</em><em>a</em><em>C</em><em>l</em><em>u</em><em>s</em><em>t</em><em>e</em><em>r</em><em>s</em>!=0)</span><br /></li>
<li>Byte no último bloco de referências onde começam as referências não válidas <br /><span class="math display">$$byteStartFreeBitmapPos = \frac{nExtraClusters}{8}$$</span><br /></li>
<li>Bit no byte acima onde começam as referências não válidas <br /><span class="math display"><em>b</em><em>i</em><em>t</em><em>S</em><em>t</em><em>a</em><em>r</em><em>t</em><em>F</em><em>r</em><em>e</em><em>e</em><em>B</em><em>i</em><em>t</em><em>m</em><em>a</em><em>p</em><em>P</em><em>o</em><em>s</em> = <em>n</em><em>E</em><em>x</em><em>t</em><em>r</em><em>a</em><em>C</em><em>l</em><em>u</em><em>s</em><em>t</em><em>e</em><em>r</em><em>s</em>%8</span><br /></li>
</ul></li>
<li>Blocos de referências completos
<ul>
<li>Para cada bloco de referências completo o número de referências é ReferencesPerBitmapBlock</li>
<li>O indice é 0 (o primeiro cluster livre está no início do bloco)</li>
</ul></li>
<li>Bloco parcialmente completo
<ul>
<li>Preencher o cnt com o número de clusters que esse bloco tem</li>
<li>Colocar os clusters não válidos como usados</li>
</ul></li>
<li>Referência do cluster 0
<ul>
<li>Indicar que está a ser usada pela root dir</li>
<li>Decrementar o count, porque existe menos um cluster vazio</li>
</ul></li>
</ul>
<h3 id="considerações-1">Considerações</h3>
<ul>
<li>O número de clusters pode ser inferior ou superior ao tamanho de um bloco.</li>
<li>O primeiro bit do primeiro bloco deve estar em use</li>
<li>Todos os bits que não referenciem um cluster devem ser colocados como em uso</li>
</ul>
<h2 id="utilização-5">Utilização</h2>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> fillInFreeClusterTable(<span class="dt">uint32_t</span> rmstart,
                            <span class="dt">uint32_t</span> ctotal 
                           )        </code></pre></div>
<h3 id="parameters-3">Parameters</h3>
<ul>
<li><strong>rmstart:</strong> the number of the fisrt block used by the bit table</li>
<li><strong>ctotal:</strong> the total number of clusters</li>
</ul>
<h3 id="data-structure">Data Structure</h3>
<p><strong>SORefBlock</strong> : estrutura dos Reference bitmap Block data type</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> SORefBlock
{
    <span class="co">/** </span><span class="an">\brief</span><span class="co"> number of references in block */</span>
    <span class="dt">uint16_t</span> cnt;
    <span class="co">/** </span><span class="an">\brief</span><span class="co"> index of first non-empty byte */</span>
    <span class="dt">uint16_t</span> idx;
    <span class="co">/** </span><span class="an">\brief</span><span class="co"> bit map */</span>
    <span class="dt">uint8_t</span> map[ReferenceBytesPerBitmapBlock];
};</code></pre></div>
<h2 id="testes-1">Testes</h2>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># 1000 blocks, 144-inodes, mksofs.bin64</span>
<span class="ex">block</span> range: 19
<span class="ex">cnt</span> = 244, idx = 0
<span class="ex">0000</span>: 7f ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff f8 00
<span class="ex">0020</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0040</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0060</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0080</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">00a0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">00c0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">00e0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0100</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0120</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0140</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0160</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0180</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">01a0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">01c0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">01e0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00


<span class="co"># 200 blocks, 48-inodes, mksofs.bin64</span>
<span class="ex">block</span> range: 7
<span class="ex">cnt</span> = 47, idx = 0
<span class="ex">0000</span>: 7f ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0020</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0040</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0060</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0080</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">00a0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">00c0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">00e0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0100</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0120</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0140</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0160</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0180</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">01a0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">01c0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">01e0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00


<span class="co"># 10000 blocks, 1264 inodes, mksofs17.bin64</span>
<span class="ex">block</span> range: 159
<span class="ex">cnt</span> = 2459, idx = 0
<span class="ex">0000</span>: 7f ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">0020</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">0040</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">0060</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">0080</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">00a0</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">00c0</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">00e0</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">0100</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
<span class="ex">0120</span>: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff f0 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0140</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0160</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">0180</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">01a0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">01c0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
<span class="ex">01e0</span>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</code></pre></div>
<h1 id="fillinrootdir">fillInRootDir</h1>
<ul>
<li>A root dir ocupa um cluster</li>
<li>Os dois primeiros slots estão reservados para as entradas “.” e “..”</li>
<li>Todos os os outros slots devem estar limpos:
<ul>
<li>o campo <em>name</em> preenchido com zeros</li>
<li>o campo <em>inode</em> preenchido com NullReference</li>
</ul></li>
</ul>
<h2 id="algoritmia-1">Algoritmia</h2>
<ul>
<li>Colocar todos os blocos com zeros</li>
<li>Na entrada 0
<ul>
<li>nome: “.”</li>
<li>inode: 0 (raiz)</li>
</ul></li>
<li>Na entrada 1
<ul>
<li>nome: “..”</li>
<li>inode: 0 (raiz)</li>
</ul></li>
</ul>
<h2 id="utilização-6">Utilização</h2>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> fillInRootDir(<span class="dt">uint32_t</span> rtstart)</code></pre></div>
<h3 id="parameters-4">Parameters</h3>
<ul>
<li><strong>rtstart:</strong> number of the block where the root cluster starts.</li>
</ul>
<h1 id="resetclusters">resetClusters</h1>
<ul>
<li>Escrever com zeros um conjunto de clusters</li>
</ul>
<h2 id="algoritmia-2">Algoritmia</h2>
<ul>
<li>Percorrer a sequência de clusters desejada e escrever zeros</li>
</ul>
<h2 id="utilização-7">Utilização</h2>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> resetClusters( <span class="dt">uint32_t</span> cstart,
                    <span class="dt">uint32_t</span> ctotal 
                  )         </code></pre></div>
<h3 id="parameters-5">Parameters</h3>
<ul>
<li><strong>cstart:</strong> number of the block of the first free cluster</li>
<li><strong>ctotal:</strong> number of clusters to be filled</li>
</ul>
<h1 id="freelists-1">freelists</h1>
<p>Functions to manage the list of free inodes and the list of free clusters</p>
<h2 id="soalloccluster">soAllocCluster</h2>
<p>uint32_t soAllocCluster ( )</p>
<p>Allocate a free cluster.</p>
<p>The cluster is retrieved from the retrieval cache of free cluster references. If the cache is empty, it has to be replenished before the retrieval may take place.</p>
<p>Returns the number of the allocated cluster</p>
<ul>
<li>Devolve um cluster livre da retrieval cache</li>
<li>Se a cache estiver vazia, replenish</li>
<li>Devolve o número do cluster alocado</li>
<li>A cache tem o valor máximo quando está cheia</li>
<li>quando está vazia o replenish é que dá reset ao idx</li>
<li><p>o idx pode não ser 0 se não estirem referências para encher a retrieval cache</p></li>
<li>Tenho de incluir o dealer do superblock (sbdealer)
<ul>
<li><strong>Não preciso de abrir o superblock</strong></li>
<li>obter pointeiro para o superblock</li>
<li>com o ponteiro obter a retrieval cache</li>
</ul></li>
<li>Tenho de decrementar o cfree do superblock</li>
<li>Só incremento o idx da cache quando tiro um valor</li>
<li><p>Tenho de escrever NullReference</p></li>
</ul>
<h3 id="tests">Tests</h3>
<ol style="list-style-type: decimal">
<li><p>Superblock view</p>
<pre><code>Header:
   Magic number: 0x41FD
   Version number: 0x2
   Volume name:
   Properly unmounted: no
   Number of mounts: 89
   Total number of blocks in the device: 0
Inode table metadata:
   First block of the inode table: 4294967295
   Number of blocks of the inode table: 4294967295
   Total number of inodes: 4294967295
   Number of free inodes: 4294967295
   Head of list of free inodes: (nil)
Free cluster table metadata:
   First block of the free cluster table: 4294967295
   Number of blocks of the free cluster table: 4294967295
   Index of first byte to retrieve references: 512
Clusters metadata:
   First block of the cluster zone: 0
   Total number of clusters: 0
   Number of free clusters: 0
   Retrieval cache:
  Index of the first filled cache element:  4294967295
  Cache contents:
     0 0 2 143 (nil) (nil) (nil) (nil) (nil) (nil)
     (nil) (nil) 512 0 0 0 0 0 3 1
     (nil) (nil) (nil) (nil) (nil) (nil) (nil) (nil) 512 0
     0 0 0 0 4 2 (nil) (nil) (nil) (nil)
     (nil) (nil) (nil) (nil) 512 0 0 0 0 0
     5 3 (nil)
   Insertion cache:
  Index of the first free cache element:  4294967295
  Cache contents:
     (nil) (nil) (nil) (nil) (nil) (nil) 512 0 0 0
     0 0 6 4 (nil) (nil) (nil) (nil) (nil) (nil)
     (nil) (nil) 512 0 0 0 0 0 7 5
     (nil) (nil) (nil) (nil) (nil) (nil) (nil) (nil) 512 0
     0 0 0 0 8 6 (nil) (nil) (nil) (nil)
     (nil) (nil) (nil)</code></pre></li>
<li><p>Testtool opening</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">(</span><span class="ex">691</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soOpenDisk(<span class="st">&quot;disk.sofs17&quot;</span>, (nil))
<span class="kw">(</span><span class="ex">991</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soOpenRawDisk(<span class="st">&quot;disk.sofs17&quot;</span>, (nil))
<span class="kw">(</span><span class="ex">891</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soOpenSBDealer()
<span class="kw">(</span><span class="ex">891</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --soOpenSBDealerBin()
<span class="kw">(</span><span class="ex">951</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soReadRawBlock(0, 0x613200)
<span class="kw">(</span><span class="ex">721</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soOpenITDealer()
<span class="kw">(</span><span class="ex">721</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --soOpenITDealerBin()
<span class="kw">(</span><span class="ex">791</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soOpenCZDealer()
<span class="kw">(</span><span class="ex">791</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --soOpenCZDealerBin()
<span class="kw">(</span><span class="ex">851</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> sbGetPointer()
<span class="kw">(</span><span class="ex">851</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --sbGetPointerBin()</code></pre></div></li>
<li><p>Allocate first cluster</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">(</span><span class="ex">501</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soAllocCluster()
<span class="kw">(</span><span class="ex">501</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --soAllocClusterBin()
<span class="kw">(</span><span class="ex">851</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> sbGetPointer()
<span class="kw">(</span><span class="ex">851</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --sbGetPointerBin()
<span class="kw">(</span><span class="ex">542</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soReplenish()
<span class="kw">(</span><span class="ex">542</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --soReplenishBin()
<span class="kw">(</span><span class="ex">851</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> sbGetPointer()
<span class="kw">(</span><span class="ex">851</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --sbGetPointerBin()
<span class="kw">(</span><span class="ex">951</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soReadRawBlock(3, 0x7ffcbb541930)
<span class="kw">(</span><span class="ex">952</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soWriteRawBlock(3, 0x7ffcbb541930)
<span class="kw">(</span><span class="ex">852</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> sbSaveBin()
<span class="kw">(</span><span class="ex">852</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --sbSaveBin()
<span class="kw">(</span><span class="ex">952</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soWriteRawBlock(0, 0x613200)
<span class="kw">(</span><span class="ex">852</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> sbSaveBin()
<span class="kw">(</span><span class="ex">852</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --sbSaveBin()
<span class="kw">(</span><span class="ex">952</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soWriteRawBlock(0, 0x613200)
<span class="ex">Cluster</span> number 1 allocated</code></pre></div></li>
<li><p>Allocate cluster without replenish</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">(</span><span class="ex">501</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soAllocCluster()
<span class="kw">(</span><span class="ex">501</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --soAllocClusterBin()
<span class="kw">(</span><span class="ex">851</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> sbGetPointer()
<span class="kw">(</span><span class="ex">851</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --sbGetPointerBin()
<span class="kw">(</span><span class="ex">852</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> sbSaveBin()
<span class="kw">(</span><span class="ex">852</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --sbSaveBin()
<span class="kw">(</span><span class="ex">952</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soWriteRawBlock(0, 0x613200)
<span class="ex">Cluster</span> number 2 allocated</code></pre></div></li>
<li><p>No space left on device</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">(</span><span class="ex">501</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soAllocCluster()
<span class="kw">(</span><span class="ex">501</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --soAllocClusterBin()
<span class="kw">(</span><span class="ex">851</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> sbGetPointer()
<span class="kw">(</span><span class="ex">851</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --sbGetPointerBin()
<span class="ex">soAllocClusterBin</span>: No space left on device (28)<span class="ex">.</span></code></pre></div></li>
<li><p>Retrieval cache empty</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">(</span><span class="ex">501</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soAllocCluster()
<span class="kw">(</span><span class="ex">501</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --soAllocClusterBin()
<span class="kw">(</span><span class="ex">851</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> sbGetPointer()
<span class="kw">(</span><span class="ex">851</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --sbGetPointerBin()
<span class="kw">(</span><span class="ex">542</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soReplenish()
<span class="kw">(</span><span class="ex">542</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --soReplenishBin()
<span class="kw">(</span><span class="ex">851</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> sbGetPointer()
<span class="kw">(</span><span class="ex">851</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --sbGetPointerBin()
<span class="kw">(</span><span class="ex">951</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soReadRawBlock(19, 0x7ffec9df02c0)
<span class="kw">(</span><span class="ex">952</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soWriteRawBlock(19, 0x7ffec9df02c0)
<span class="kw">(</span><span class="ex">852</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> sbSaveBin()
<span class="kw">(</span><span class="ex">852</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --sbSaveBin()
<span class="kw">(</span><span class="ex">952</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soWriteRawBlock(0, 0x613200)
<span class="kw">(</span><span class="ex">852</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> sbSaveBin()
<span class="kw">(</span><span class="ex">852</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> --sbSaveBin()
<span class="kw">(</span><span class="ex">952</span><span class="kw">)</span><span class="ex">--</span><span class="op">&gt;</span> soWriteRawBlock(0, 0x613200)
<span class="ex">Cluster</span> number 54 allocated</code></pre></div></li>
</ol>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./createDisk</span> disk.sofs17 10 <span class="kw">&amp;&amp;</span> <span class="ex">./mksofs.bin64</span> disk.sofs17 <span class="kw">&amp;&amp;</span> <span class="ex">./testtool</span> disk.sofs17 -l 0,999</code></pre></div>
<p>Cluster number é sempre MAX_UINT32 Dá replenish ad eternum</p>
<ol start="2" style="list-style-type: decimal">
<li><p>Disco 100</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">./createDisk</span> disk.sofs17 100 <span class="kw">&amp;&amp;</span> <span class="ex">./mksofs.bin64</span> disk.sofs17 <span class="kw">&amp;&amp;</span> <span class="ex">./testtool</span> disk.sofs17 -l 0,999</code></pre></div>
<p>Inicia com MAX_UINT32 Depois as referências ficam bem mas o idx começa em 30 Indice chega aos 53 com o cluster em 23. Dá replenish e core dumped</p></li>
</ol>
<p>Para 200 a mesma coisa -&gt; 48 inodes Para 250 não -&gt; 32 inodes Para 300 não -&gt; 48 inodes</p>
<p>[AQUI] ### sbdealer superblock dealer: mediates access to the disk superblock More…</p>
<p>Functions</p>
<pre><code>         void  soOpenSBDealer ()
               Open the superblock dealer. More...

         void  soCloseSBDealer ()
               Close the superblock dealer. More...</code></pre>
<p>SOSuperBlock * sbGetPointer () Get a pointer to the superblock. More…</p>
<pre><code>         void  sbSave ()
               Save superblock to disk. More...</code></pre>
<p>Detailed Description</p>
<p>superblock dealer: mediates access to the disk superblock</p>
<p>This module guarantees that only a single copy of the superblock is in memory, thus improving its consistency.</p>
<p>Remarks In case an error occurs, every function throws a SOException</p>
<p>SOSuperBlock* sbGetPointer ( )</p>
<p>Get a pointer to the superblock.</p>
<p>Load the superblock, if not done yet</p>
<p>Returns Pointer to superblock</p>
<p>void sbSave ( )</p>
<p>Save superblock to disk.</p>
<p>Do nothing if not loaded</p>
<p>void soCloseSBDealer ( )</p>
<p>Close the superblock dealer.</p>
<p>Save superblock to disk and close dealer</p>
<p>void soOpenSBDealer ( )</p>
<p>Open the superblock dealer.</p>
<p>Prepare the internal data structure of the superblock dealer</p>
<h2 id="soallocinode">soAllocInode</h2>
<p>uint32_t soAllocInode ( uint32_t type )</p>
<p>Allocate a free inode.</p>
<p>An inode is retrieved from the list of free inodes, marked in use, associated to the legal file type passed as a parameter and is generally initialized.</p>
<p>Parameters</p>
<pre><code>     type the inode type (it must represent either a file, or a
          directory, or a symbolic link)</code></pre>
<p>Returns the number of the allocated inode</p>
<h2 id="sofreecluster">soFreeCluster</h2>
<p>void soFreeCluster ( uint32_t cn )</p>
<p>Free the referenced cluster.</p>
<p>Parameters</p>
<pre><code>      cn the number of the cluster to be freed</code></pre>
<h2 id="sofreeinode">soFreeInode</h2>
<p>void soFreeInode ( uint32_t in )</p>
<p>Free the referenced inode.</p>
<p>The inode is inserted into the list of free inodes.</p>
<p>Parameters</p>
<pre><code>      in number of the inode to be freed</code></pre>
<h2 id="soreplenish">soReplenish</h2>
<p>void soReplenish ( )</p>
<p>replenish the retrieval cache</p>
<p>References to free clusters should be transfered from the free cluster table (bit map) or insertion cache to the retrieval cache. Nothing should be done if the retrieval cache is not empty. The insertion cache should only be used if there are no bits at one in the map. Only a single block should be processed, even if it is not enough to fulfill the retrieval cache. The block to be processes is the one pointed to by the rmidx field of the superblock. This field should be updated if the processing of the current block reaches its end.</p>
<h2 id="sodeplete">soDeplete</h2>
<p>[MISING IN DOXYGEN]</p>
<p>Functions</p>
<p>uint32_t soAllocInode (uint32_t type) Allocate a free inode. More…</p>
<pre><code>   void  soFreeInode (uint32_t in)
         Free the referenced inode. More...</code></pre>
<p>uint32_t soAllocCluster () Allocate a free cluster. More…</p>
<pre><code>   void  soReplenish ()
         replenish the retrieval cache More...

   void  soFreeCluster (uint32_t cn)
         Free the referenced cluster. More...

   void  soDeplete ()
         Deplete the insertion cache.</code></pre>
<p>Detailed Description</p>
<p>Functions to manage the list of free inodes and the list of free clusters.</p>
<h1 id="cenário-inicial">Cenário Inicial</h1>
<p>campo ihead superblock: 101 campo ifree : 3</p>
<p>inode previous|next</p>
<p>101 7|5</p>
<p>5 10|7</p>
<p>7 5/101</p>
<h2 id="freeinode">freeinode</h2>
<ul>
<li>Quero libertar o nó numero 200</li>
<li>mante o tipo</li>
<li>apenas altera flag para free</li>
<li>o ficheiro passa a ser deleted file</li>
<li>o nó que é libertado é obviamente o ultimo</li>
</ul>
<h2 id="inserir-inode-200">inserir inode 200</h2>
<p>200 7|101</p>
<p>101 200|5</p>
<p>5 10/7</p>
<p>7 5|200</p>
<p>200 7|101</p>
<p>ihead:101 ifree: 4</p>
<h2 id="soallocateinode">soAllocateInode</h2>
<ul>
<li>Retirar o nó da lista de inodes</li>
<li>O primeiro no a retirar é o que apontado pelo ihead</li>
</ul>
<p>ihead:5 ifree:2</p>
<p>5 7|7</p>
<p>7 5|5</p>
<p>Só pode existir uma cópia do suoerbloco</p>
<h2 id="iopen">iOpen</h2>
<ul>
<li>Abrir o inode
<ul>
<li>so o volta a ler do disco se já foi aberto</li>
<li>só posso pedir um pointer para esse inode</li>
<li>devolve me um inode handler</li>
<li>in: inode number</li>
<li>ih: inode handler</li>
<li>ip: inode pointer</li>
</ul></li>
</ul>
<h2 id="isave">iSave</h2>
<ul>
<li>Guardar um inode</li>
</ul>
<h2 id="iclose">iClose</h2>
<ul>
<li>Guardar o ficheiro</li>
</ul>
<h2 id="interface-com-os-inodes-é-suposto-usar-uma-estrutura-de-inodes">Interface com os inodes é suposto usar uma estrutura de inodes</h2>
<p>função replentish tem como função transferir blocos para a cache - transforma bits em referências - os bits que forem transferidos vão passar de 1 a zero - rmidx: primeiro byte do map de bit que tem bits a 1 - comece por aqui. Antes não há bits a 1</p>
<h1 id="mais-difícis-5">mais difícis (5)</h1>
<p>soReplenish (Patricia) soDeplete (Bernardo)</p>
<h1 id="intermédias-3">intermédias (3)</h1>
<p>soAllocateInode (panda) soFreeInode (Gradim)</p>
<h1 id="mais-triviais-1">mais triviais (1)</h1>
<p>soAllocClusters (Pedro) soFreeClusters (Mica) uint32_t soAllocInode ( uint32_t type )</p>
<p>Allocate a free inode.</p>
<p>An inode is retrieved from the list of free inodes, marked in use, associated to the legal file type passed as a parameter and is generally initialized.</p>
<p>Parameters</p>
<pre><code>      type the inode type (it must represent either a file, or a directory, or a symbolic link)</code></pre>
<p>Returns the number of the allocated inode</p>
<ul>
<li>Se for possível, aloca o inode que está na HEAD</li>
<li>Incrementa a HEAD
<ul>
<li>tem de verificar se a inode table está no fim e se tem de voltar aos inodes que entretanto foram libertados</li>
</ul></li>
<li>Decrementa o número de inodes livres</li>
<li>O inode tem de ser corretamente inicializado # Inodes</li>
<li>Existem 6 posições para referência direta aos clusters do ficheiro
<ul>
<li>d[0 … 5]</li>
</ul></li>
<li>Uma posição para referência indireta
<ul>
<li>i1</li>
<li>Extende o array de d[6 … 517]</li>
</ul></li>
<li><h2 id="uma-posição-para-referência-dupla-indireta">Uma posição para referência dupla indireta</h2></li>
<li>Cada ficheiro possui um inode
<ul>
<li>O número máximo de ficheiros num disco é o número máximo de inodes</li>
</ul></li>
<li>Um inode ocupa 64 bytes
<ul>
<li>Logo num disco com 512 bytes por bloco, existem 8 inodes em cada bloco # Fileclusters Functions to manage the clusters belonging by a file</li>
</ul></li>
</ul>
<h2 id="doxygen">Doxygen</h2>
<p>uint32_t soGetFileCluster (int ih, uint32_t fcn) Get the cluster number of a given file cluster. More…</p>
<p>uint32_t soAllocFileCluster (int ih, uint32_t fcn) Associate a cluster to a given file cluster position. More…</p>
<pre><code>  void  soFreeFileClusters (int ih, uint32_t ffcn)
        Free all file clusters from the given position on.
        More...

  void  soReadFileCluster (int ih, uint32_t fcn, void *buf)
        Read a file cluster. More...

  void  soWriteFileCluster (int ih, uint32_t fcn, void *buf)
        Write a data cluster. More...</code></pre>
<p>Detailed Description</p>
<p>Functions to manage the clusters belonging by a file.</p>
<p>Author Artur Pereira - 2008-2009, 2016-2017 Miguel Oliveira e Silva - 2009, 2017 António Rui Borges - 2010-2015</p>
<p>Remarks In case an error occurs, every function throws an SOException</p>
<p>Function Documentation</p>
<p>uint32_t soAllocFileCluster ( int ih, uint32_t fcn )</p>
<p>Associate a cluster to a given file cluster position.</p>
<p>Parameters</p>
<pre><code>      ih  inode handler
      fcn file cluster number</code></pre>
<p>Returns the number of the allocated cluster</p>
<p>void soFreeFileClusters ( int ih, uint32_t ffcn )</p>
<p>Free all file clusters from the given position on.</p>
<p>Parameters</p>
<pre><code>      ih   inode handler
      ffcn first file cluster number</code></pre>
<h3 id="uint32_t-sogetfilecluster-int-ih">uint32_t soGetFileCluster ( int ih,</h3>
<pre><code>                           uint32_t  fcn
                         )</code></pre>
<p>Get the cluster number of a given file cluster.</p>
<p>Parameters</p>
<pre><code>      ih  inode handler
      fcn file cluster number</code></pre>
<p>Returns the number of the corresponding cluster</p>
<ul>
<li>Parece me que apenas tenho de retornar o endereço do cluster</li>
<li>Não é preciso retornar tudo</li>
<li>Mandar mail ao professor</li>
<li>Perguntar panda</li>
<li>Para que servem as fnções do prof??</li>
<li>Aquilo que faz é usar o inode handler para saber onde está no disk e o file cluster number para obter a referência</li>
<li>É preciso rever as duas estruturas
<ul>
<li>superblock</li>
<li>inode</li>
<li>cluster</li>
</ul></li>
</ul>
<h4 id="o-que-é-preciso-fazer">O que é preciso fazer:</h4>
<ul>
<li>Obter o inode</li>
<li>Se o cluster index estiver nos 6 primeiros
<ul>
<li>Sai direto da estrutura de inodes</li>
</ul></li>
<li>Se o cluster index for referenciado diretamente (<span class="math inline"><em>i</em><sub>1</sub></span>)
<ul>
<li>está no cluster de referências</li>
<li>Ler esse cluster do disco</li>
<li>Calcular novo index (subtrair 6?)</li>
<li>Ler Retornar a referência em que este está</li>
</ul></li>
<li>Se o cluste index estiver no cluster de referências indiretas (<span class="math inline"><em>i</em><sub>2</sub></span>)
<ul>
<li>Calcular dois novos indexes:
<ul>
<li>index no cluster de referências indiretas</li>
<li>index no cluster de referências diretas</li>
</ul></li>
<li>Ler a referência do disco</li>
<li>Retornar o valor</li>
</ul></li>
<li>A testtool já trata de fazer o iOpen</li>
<li>A soGetFileCluster é chamada com o indice do inode</li>
<li>É preciso usar a <code>iGetPointer</code> para obter o ponteiro para a estrutura</li>
</ul>
<h4 id="testes-2">Testes</h4>
<p>+================================================================+ | testing functions | +================================================================+ | q - exit | sb - show block | | fd - format disk | spd - set probe depths | +——————————–+——————————-+ | ai - alloc inode | fi - free inode | | ac - alloc cluster | fc - free cluster | | r - replenish | d - deplete | +——————————–+——————————-+ | gfc - get file cluster | afc - alloc file cluster | | ffc - free file clusters | - NOT USED | | rfc - read file cluster | wfc - write file cluster | +——————————–+——————————-+ | gde - get dir entry | ade - add dir entry | | rde - rename dir entry | dde - delete dir entry | | tp - traverse path | - NOT USED | +——————————–+——————————-+ + cia - check inode access | sia - set inode access + + iil - increment inode lnkcnt | dil - decrement inode lnkcnt + +================================================================+</p>
<p>Your command: gfc Inode number: 1 File cluster index: 7 (711)–&gt; iOpen(1) (711)–&gt; –iOpenBin(1) (403)–&gt; soGetFileCluster(0, 7) (403)–&gt; –soGetFileClusterBin(0, 7) (712)–&gt; iGetPointer(0) (712)–&gt; –iGetPointerBin(0) (714)–&gt; iClose(0) (714)–&gt; –iCloseBin(0) Cluster number (nil) retrieved +================================================================+ | testing functions | +================================================================+ | q - exit | sb - show block | | fd - format disk | spd - set probe depths | +——————————–+——————————-+ | ai - alloc inode | fi - free inode | | ac - alloc cluster | fc - free cluster | | r - replenish | d - deplete | +——————————–+——————————-+ | gfc - get file cluster | afc - alloc file cluster | | ffc - free file clusters | - NOT USED | | rfc - read file cluster | wfc - write file cluster | +——————————–+——————————-+ | gde - get dir entry | ade - add dir entry | | rde - rename dir entry | dde - delete dir entry | | tp - traverse path | - NOT USED | +——————————–+——————————-+ + cia - check inode access | sia - set inode access + + iil - increment inode lnkcnt | dil - decrement inode lnkcnt + +================================================================+</p>
<p>Your command: gfc Inode number: 1 File cluster index: 8 (711)–&gt; iOpen(1) (711)–&gt; –iOpenBin(1) (403)–&gt; soGetFileCluster(0, 8) (403)–&gt; –soGetFileClusterBin(0, 8) (712)–&gt; iGetPointer(0) (712)–&gt; –iGetPointerBin(0) (714)–&gt; iClose(0) (714)–&gt; –iCloseBin(0) Cluster number (nil) retrieved +================================================================+ | testing functions | +================================================================+ | q - exit | sb - show block | | fd - format disk | spd - set probe depths | +——————————–+——————————-+ | ai - alloc inode | fi - free inode | | ac - alloc cluster | fc - free cluster | | r - replenish | d - deplete | +——————————–+——————————-+ | gfc - get file cluster | afc - alloc file cluster | | ffc - free file clusters | - NOT USED | | rfc - read file cluster | wfc - write file cluster | +——————————–+——————————-+ | gde - get dir entry | ade - add dir entry | | rde - rename dir entry | dde - delete dir entry | | tp - traverse path | - NOT USED | +——————————–+——————————-+ + cia - check inode access | sia - set inode access + + iil - increment inode lnkcnt | dil - decrement inode lnkcnt + +================================================================+</p>
<p>Your command: gfc Inode number: 0 File cluster index: 1 (711)–&gt; iOpen(0) (711)–&gt; –iOpenBin(0) (851)–&gt; sbGetPointer() (851)–&gt; –sbGetPointerBin() (951)–&gt; soReadRawBlock(1, 0x7fffd273b450) (403)–&gt; soGetFileCluster(1, 1) (403)–&gt; –soGetFileClusterBin(1, 1) (712)–&gt; iGetPointer(1) (712)–&gt; –iGetPointerBin(1) (714)–&gt; iClose(1) (714)–&gt; –iCloseBin(1) Cluster number (nil) retrieved +================================================================+ | testing functions | +================================================================+ | q - exit | sb - show block | | fd - format disk | spd - set probe depths | +——————————–+——————————-+ | ai - alloc inode | fi - free inode | | ac - alloc cluster | fc - free cluster | | r - replenish | d - deplete | +——————————–+——————————-+ | gfc - get file cluster | afc - alloc file cluster | | ffc - free file clusters | - NOT USED | | rfc - read file cluster | wfc - write file cluster | +——————————–+——————————-+ | gde - get dir entry | ade - add dir entry | | rde - rename dir entry | dde - delete dir entry | | tp - traverse path | - NOT USED | +——————————–+——————————-+ + cia - check inode access | sia - set inode access + + iil - increment inode lnkcnt | dil - decrement inode lnkcnt + +================================================================+</p>
<h2 id="your-command">Your command:</h2>
<h3 id="void-soreadfilecluster-int-ih">void soReadFileCluster ( int ih,</h3>
<pre><code>                        uint32_t  fcn,
                        void *    buf
                      )</code></pre>
<p>Read a file cluster.</p>
<p>Data is read from a specific data cluster which is supposed to belong to an inode associated to a file (a regular file, a directory or a symbolic link).</p>
<p>If the referred file cluster has not been allocated yet, the returned data will consist of a byte stream filled with the character null (ascii code 0).</p>
<p>Parameters</p>
<pre><code>      ih  inode handler
      fcn file cluster number
      buf pointer to the buffer where data must be read into</code></pre>
<p>void soWriteFileCluster ( int ih, uint32_t fcn, void * buf )</p>
<p>Write a data cluster.</p>
<p>Data is written into a specific data cluster which is supposed to belong to an inode associated to a file (a regular file, a directory or a symbolic link).</p>
<p>If the referred cluster has not been allocated yet, it will be allocated now so that the data can be stored as its contents.</p>
<p>Parameters</p>
<pre><code>      ih  inode handler
      fcn file cluster number
      buf pointer to the buffer containing data to be written</code></pre>
<h2 id="sofreefileclusters">soFreeFileCLusters</h2>
<ul>
<li>Liberta todos os clusters do inode começando na posição atual</li>
<li>Se o inode ficar sem clusters, é apagado # direntries</li>
</ul>
<h1 id="sogetdirentry">soGetDirEntry</h1>
<ul>
<li>Obtem o inode associado ao nome da função</li>
<li>É preciso fazer o parse do nome do diretório para chegar ao diretório pretendido</li>
<li><p>Chama a traverse Path</p></li>
<li><p>Tem de verificar se a entrada já existe</p></li>
</ul>
<p>uint32_t soGetDirEntry ( int pih, const char * name )</p>
<p>Get the inode associated to the given name.</p>
<p>The directory contents, seen as an array of directory entries, is parsed to find an entry whose name is name.</p>
<p>The name must also be a base name and not a path, that is, it can not contain the character ‘/’.</p>
<p>Parameters</p>
<pre><code>      pih  inode handler of the parent directory
      name the name entry to be searched for</code></pre>
<p>Returns the corresponding inode number</p>
<h1 id="sorenamedirentry">soRenameDirEntry</h1>
<ul>
<li>Renomeia a entrada de um diretório</li>
</ul>
<p>void soRenameDirEntry ( int pih, const char * name, const char * newName )</p>
<p>Rename an entry of a directory.</p>
<p>A direntry associated from the given directory is renamed.</p>
<p>Parameters</p>
<pre><code>      pih     inode handler of the parent inode
      name    current name of the entry
      newName new name for the entry</code></pre>
<h1 id="sotraversepath">soTraversePath</h1>
<ul>
<li>Obtem o inode associado com um dado caminho</li>
<li>Atravessa a estrutura do sistema do sistema de ficheiros para obter o inode cujo nome do ficheiro é a componente mais à direita do caminho</li>
<li>O caminho deve ser absoluto</li>
<li>Todos elementos do caminho (com exceção do último) devem ser diretório ou symbolic links com permissão de travers (x)</li>
</ul>
<p>uint32_t soTraversePath ( char * path )</p>
<p>Get the inode associated to the given path.</p>
<p>The directory hierarchy of the file system is traversed to find an entry whose name is the rightmost component of path. The path is supposed to be absolute and each component of path, with the exception of the rightmost one, should be a directory name or symbolic link name to a path.</p>
<p>The process that calls the operation must have execution (x) permission on all the components of the path with exception of the rightmost one.</p>
<p>Parameters</p>
<pre><code>      path the path to be traversed</code></pre>
<p>Returns the corresponding inode number</p>
<h1 id="soadddirentry">soAddDirEntry</h1>
<ul>
<li>Adiciona uma nova entrada no diretório pai</li>
<li>Uma direntry é adicionada ligando o parent inode ao child inode
<ul>
<li>O lnkcnt do inode filho <strong>não</strong> é incrementado nesta função</li>
</ul></li>
</ul>
<p>void soAddDirEntry ( int pih, const char * name, uint32_t cin )</p>
<p>Add a new entry to the parent directory.</p>
<p>A direntry is added connecting the parent inode to the child inode. The refcount of the child inode is not incremented by this function.</p>
<p>Parameters</p>
<pre><code>      pih  inode handler of the parent inode
      name name of the entry
      cin  number of the child inode</code></pre>
<h1 id="sodeletedirentry">soDeleteDirEntry</h1>
<ul>
<li>Remove uma entrada do parent directory</li>
<li>O lnkcnt do inode filho <strong>não</strong> é decrementado</li>
</ul>
<p>uint32_t soDeleteDirEntry ( int pih, const char * name, bool clean = false )</p>
<p>Remove an entry from a parent directory.</p>
<p>A direntry associated from the given directory is deleted. The refcount of the child inode is not decremented by this function.</p>
<p>Parameters</p>
<pre><code>      pih   inode handler of the parent inode
      name  name of the entry
      clean if true (different than zero) clean the corresponding dir entry, otherwise keep it dirty</code></pre>
<p>Returns the inode number in the deleted entry</p>
<h1 id="extra">Extra</h1>
<p>filesystem check - atribui ficheiros para a o disco sempre que uma função falahe gera uma exceção</p>
<h1 id="sorenamedirentry-1">soRenameDirEntry</h1>
<ul>
<li>dá um novo nome ao diretório</li>
</ul>
<h1 id="sodeletedirentry-1">soDeleteDirEntry</h1>
<ul>
<li>remove o diretório</li>
</ul>
<h1 id="sogetdirentry-1">soGetDirEntry</h1>
<ul>
<li>quando alguém a nível superior quer abrir/escrever, ver permissões precisa de sabe o inode # itdealer</li>
<li>Conjunto de funções que manipulam diretamente a estrutura de inodes</li>
</ul>
<h2 id="iopen-1">iOpen</h2>
<ul>
<li>Abre um inode
<ul>
<li>Transfere o seu conteudo para a memória</li>
<li>Set ao <em>usecount</em></li>
</ul></li>
<li>Caso o inode já esteja aberto, incrementa a <em>usecount</em></li>
<li>Em qualquer dos casos devolve o handler (referência para a posição de memória) para o inode # Syscalls</li>
</ul>
<h2 id="main-syscalls">Main syscalls</h2>
<ul>
<li><strong>soLInk:</strong> Cria um link para um ficheiro</li>
<li><strong>soMkdir:</strong> Cria um diretório</li>
<li><strong>soMknod:</strong> Cria um ficheiro regular com tamanho nulo</li>
<li><strong>soRead:</strong> Lê os dados de um ficheiro regular previamente aberto</li>
<li><strong>soReaddir:</strong> Lê uma entrada para um diretório de um dado diretório</li>
<li><strong>soReadLink:</strong> Lê um <em>symbolic link</em></li>
<li><strong>soRename:</strong> Muda um nome de um ficheiro ou a sua localização na estrutura de diretórios</li>
<li><strong>soRmdir:</strong> Remover um diretório
<ul>
<li>O diretório de ve estar vazio</li>
</ul></li>
<li><strong>soSymlink:</strong> Cria um symbolic link com o caminho desejado</li>
<li><strong>soTruncate:</strong> Trunca o tamanho de um regular file para o desejado</li>
<li><strong>soUnlink:</strong> Remove um link para um ficheiro através de um diretório
<ul>
<li>Remove também o ficheiro se o lnkcnt = 0</li>
</ul></li>
<li><p><strong>soWrite:</strong> Escreve dados num regular file previamente aberto</p></li>
<li><p><strong>exceptions</strong> : sofs17 exception definition module ```cpp struct SOException:public std::exception int en; ///&lt; (system) error number const char *msg; ///&lt; name of function that has thrown the exception</p></li>
</ul>
<p>digraph x{ a -&gt; b [label=“b”] a -&gt; c [label=“a”] a -&gt; d [label=“d”] } # Existem duas camadas de syscalls - main syscalls - 12 funções (temos de saber para o mini teste) - other syscalss</p>
<h2 id="solink">soLink</h2>
<ul>
<li>Usar a transverse path para saber qual o nó que está na ponta</li>
<li>link(“/b”, “a/c”)
<ul>
<li>saber qual é o nó que está na pomnta do /b
<ul>
<li>uso o traverse para saber</li>
<li>abro e pergunto para saber o tipo</li>
<li>base name</li>
<li>verifico se é o diretório e tenho permissoes de excrita</li>
<li>verifico se ja tem o ficheirp que quero criar</li>
<li>chamar idirentry para criar o diretorio</li>
<li>chamar increment link count</li>
</ul></li>
</ul></li>
</ul>
<h2 id="unlink">unLink</h2>
<ul>
<li>Não apaga o ficheiro</li>
<li>Quebra a ligaão</li>
<li>dde - delete dir entry</li>
<li>decrementa o link count</li>
<li>se o tiver 0 links
<ul>
<li>chama a free inode para libertar o inode</li>
<li>chama a free cluster para libertar o cluster</li>
</ul></li>
<li>APgar ficheiros é derivado do unlink</li>
</ul>
<p>Enquanto o ficheiro estive aberto não pode ser destruido É o close do sistema operativo que apaga um fucheiro</p>
<h2 id="sorename">soRename</h2>
<ul>
<li>função complicada</li>
<li>soRename(“/b”, “/a/c”)</li>
<li><p>OU é um rename se o novo pathe e o path antigo orem iguais</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">    <span class="ex">soRename</span>(<span class="st">&quot;/b&quot;</span>, <span class="st">&quot;/c&quot;</span>)</code></pre></div></li>
<li>Equivale no caso do move a fazer delete direentry e add direntry</li>
<li>Não tem o link nem o dec</li>
<li><p>O nó de destino passa a ser o mesmo</p></li>
</ul>
<h2 id="somknod">soMKnod</h2>
<ul>
<li>Cria um nod do tipo ficheiro</li>
<li>COrrepsonde a fazer:
<ul>
<li>Começar por criar um inode: alloc indode,</li>
<li>add dir entry</li>
<li>increment link count</li>
</ul></li>
<li>Tem de validar primeiro:
<ul>
<li>Verificar se o “/a” existe, é um diretório e tem permisssoes de escrita</li>
<li>Verificar se o “/c” não existe</li>
</ul></li>
</ul>
<h2 id="soread">soRead</h2>
<ul>
<li>Posso quer ler dois bytes e ter de ler dois clusters
<ul>
<li>Ultimo byte do 1º cluster</li>
<li>Primeiro byte do 2º cluster</li>
</ul></li>
<li>A função read não pode ler para a lém do fim de ficheiro</li>
<li>O size é que determina o fim do ficheiroo</li>
<li>Indiretamento o write també, pode alocar clusters</li>
<li>Tipicamente o wrtie tem de ler priemiro caos vá alterar parcialemtne um cluster</li>
<li>O que interessa em termos de miniteste é o papel e efeito da função, não como o ocódigo é feito</li>
<li>O que interessa é a consequemncia da execuação de u comando</li>
</ul>
<h2 id="sotrucnate">soTrucnate</h2>
<ul>
<li>Alçtera o tamanho de um gicheiro ou para cima ou para baixo</li>
<li>È assim que se cria buracos num ficheiro
<ul>
<li>Trunco e vou acrescentando</li>
</ul></li>
<li>Gunção joga com o size e</li>
<li>Trunco o tamanho para 10</li>
<li>Depois volto a troncar para 20
<ul>
<li>Ou no truncar para cima ou no truncar para baixo tenho de garantir que nºao existe lixo entre as zonas dos meus dados
<ul>
<li>Ou escrevo zeros., ou escrevo NullReferences
<ul>
<li>Null References dentro do size são lidas como zeros</li>
</ul></li>
</ul></li>
<li>O ficheiro é o mesmo, estou só a alterar o tamanho que esse ficheiro tem no disco</li>
<li>O truncate não quer saber o que lá está, simplesmente trunca os dados inteirores</li>
<li>Ou eu ponho zeros quando encolhi, ou ponho zeros quando abro</li>
</ul></li>
<li>Se fize ro fopne de um ficheiro já abero, o SO chama a truncate e mete os dados desse ficheiro a zero</li>
</ul>
<h2 id="somkdir">soMkdir</h2>
<ul>
<li>Sempre ue há u novo direentry é preciso adicionar o linkcount</li>
<li>Pressuposto: só se pode aoagar diretórios vazios</li>
<li>Ler man2 para saber os erros que tem de emitir</li>
</ul>
<h2 id="soreaddir">soReadDIr</h2>
<ul>
<li>É usado para fazer o ls</li>
<li>Leê entradas de um diretorio</li>
<li>Sempre que esta funlção é lida, ele vai ler a próxima direntry</li>
<li>Em cadainvocaçáo eu tenho que lhe dzwr qenaotos bytes já passei</li>
<li>Posso ter de processar duas entradas para lhe dar uma . QUando a fubnção rreaddir devolve zero, já não existem mais entradas naquele deiretorio</li>
</ul>
<h2 id="sosymlink">soSymlink</h2>
<ul>
<li>Creates a symbolic link</li>
</ul>
<h2 id="so-readlink">so ReadLink</h2>
<ul>
<li>Valor de retorno do symbolic link # HOW to use sofs17 (so1718 - Aula prática 29 Sep) ## Documentação</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># Gerar documentação</span>
<span class="bu">cd</span> ./doc
<span class="ex">doxygen</span></code></pre></div>
<p>A documentação fica na pasta <code>./doc/html/</code></p>
<h1 id="make">Make</h1>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># O make compila sempre tudo e não somente o conteudo da pasta</span>
<span class="fu">make</span>
<span class="fu">make</span> -C <span class="op">&lt;</span>path_to_start<span class="op">&gt;</span>     % indica o caminho onde o make começar</code></pre></div>
<p>Na linkagem necessita da biblioteca fuse.h. Está contida na biblioteca libfuse-dev que pode ser instalada com:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">sudo</span> apt-get install libfuse-dev</code></pre></div>
<p>[TODO] mksofs - msksofs : formatador para o sistema de ficheiros sofs17</p>
<p>Para já as funções</p>
<ul>
<li>compute structure:
<ul>
<li>nao altera os dados no disco.</li>
<li>Apenas calcula os blocos de inodes, clusters, etc.</li>
</ul></li>
<li>cada função vai preencher a àrea do disco respetiva
<ul>
<li><strong>fillInSuperBlock</strong> : computes the structural division of the disk</li>
<li><strong>fillInInodeTable</strong> :</li>
</ul></li>
</ul>
<h1 id="sofreefileclusters-1">soFreeFileCLusters</h1>
<ul>
<li>Apagamento da esquerda para a direita</li>
<li>As posições são alteradas e escritas com Null Reference</li>
<li>o size só é alterado por syscalls e não ao libertar um inode/cluster</li>
</ul>
<h1 id="section-3"></h1>
<ul>
<li>Um diretório tem um size múltiplo do cluster</li>
<li>Os diretórios crescem cluster a cluster</li>
</ul>
<h1 id="section-4"></h1>
<p>uint32_t soGetDirEntry ( int pih, const char * name )</p>
<p>Get the inode associated to the given name.</p>
<p>The directory contents, seen as an array of directory entries, is parsed to find an entry whose name is name.</p>
<p>The name must also be a base name and not a path, that is, it can not contain the character ‘/’.</p>
<p>Parameters</p>
<pre><code>      pih  inode handler of the parent directory
      name the name entry to be searched for</code></pre>
<p>Returns the corresponding inode number</p>
<h1 id="section-5"></h1>
<p>uint32_t soDeleteDirEntry ( int pih, const char * name, bool clean = false )</p>
<p>Remove an entry from a parent directory.</p>
<p>A direntry associated from the given directory is deleted. The refcount of the child inode is not decremented by this function.</p>
<p>Parameters</p>
<pre><code>      pih   inode handler of the parent inode
      name  name of the entry
      clean if true (different than zero) clean the corresponding dir entry, otherwise keep it dirty</code></pre>
<p>Returns the inode number in the deleted entry</p>
<p>Comentários - soWriteRawBlock - char blk[blockSize] - SOSuperblock sb; - SOTnode it[inodesPerBlock] - soWriteRawBlock(uint32_t n, void *buf) - blk - fsb - it</p>
<h2 id="notes">Notes</h2>
<p>função alloc cluster tem de verificar se ficou tudo bem no disco função replentish transfer da reference bitmao block para a retrieval cache</p>
<p>Capacidade: (6+ 2^9 + (2<sup>9)</sup>2)x 2^11</p>
<h1 id="nov-2017">3 Nov 2017</h1>
<ul>
<li>As direntries não mexem no lnkcnt</li>
<li>Add mexe no size</li>
</ul>
<h1 id="unlink-1">Unlink</h1>
<ol style="list-style-type: decimal">
<li>dde</li>
<li>dec</li>
<li>if(dec ==0) 3.1 ffc 3.2 fi</li>
</ol>
<p>O dec devolve o devolve</p>
<h1 id="remove">Remove</h1>
<h1 id="mtime-vs-ctime">mtime vs ctime</h1>
<ul>
<li><strong>mtime:</strong> conteudo do ficheiro</li>
<li><p><strong>ctime:</strong> metadados do ficheiro</p></li>
<li><p>Não podemos ter nenhum diretório apontado por dois diretórios</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">ln</span>: <span class="st">&#39;ddd/&#39;</span>: hard link not allowwd for directory</code></pre></div></li>
</ul>
</body>
</html>
